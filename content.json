{"meta":{"title":"飞羽的博客","subtitle":"飞羽个人博客","description":"程序猴一枚，目前主要从事于基于iOS,Flutter,Android的App移动端开发","author":"飞羽","url":"https://ifeiyv.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2020-03-17T03:46:59.440Z","updated":"2020-03-17T03:46:59.433Z","comments":true,"path":"categories/index.html","permalink":"https://ifeiyv.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-03-17T03:49:22.512Z","updated":"2020-03-17T03:49:22.500Z","comments":true,"path":"friends/index.html","permalink":"https://ifeiyv.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2020-03-17T06:19:07.186Z","updated":"2020-03-17T06:19:07.174Z","comments":true,"path":"mylist/index.html","permalink":"https://ifeiyv.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-17T03:44:56.309Z","updated":"2020-03-17T03:44:56.302Z","comments":true,"path":"tags/index.html","permalink":"https://ifeiyv.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-17T03:49:03.925Z","updated":"2020-03-17T03:49:03.916Z","comments":true,"path":"about/index.html","permalink":"https://ifeiyv.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"404 Not Found","date":"2020-03-17T09:51:35.499Z","updated":"2020-03-17T09:51:35.491Z","comments":true,"path":"404.html","permalink":"https://ifeiyv.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"Mac 文件已损坏或者未知开发者解决办法","slug":"Mac 文件已损坏或者未知开发者解决办法","date":"2020-03-17T08:01:03.000Z","updated":"2020-03-17T08:02:31.990Z","comments":true,"path":"2020/03/17/Mac 文件已损坏或者未知开发者解决办法/","link":"","permalink":"https://ifeiyv.github.io/2020/03/17/Mac%20%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%E6%88%96%E8%80%85%E6%9C%AA%E7%9F%A5%E5%BC%80%E5%8F%91%E8%80%85%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"sudo spctl –master-disable (所有来源权限)各位注意，这是10.15以上系统的完美解决方法打开终端（Terminal），输入以下命令后回车，如需要，请输入密码sudo xattr -r -d com.apple.quarantine 注：为应用程序路径，直接从文件夹目录拖拽即可自动填写","categories":[{"name":"Mac","slug":"Mac","permalink":"https://ifeiyv.github.io/categories/Mac/"}],"tags":[{"name":"文件已损坏解决办法","slug":"文件已损坏解决办法","permalink":"https://ifeiyv.github.io/tags/%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"name":"未知开发者解决办法","slug":"未知开发者解决办法","permalink":"https://ifeiyv.github.io/tags/%E6%9C%AA%E7%9F%A5%E5%BC%80%E5%8F%91%E8%80%85%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"}]},{"title":"结合RxSwift、Moya、和HandyJSON封装网络请求模板","slug":"结合RxSwift、Moya、和HandyJSON封装网络请求模板","date":"2020-03-16T06:43:52.000Z","updated":"2020-03-17T09:06:40.315Z","comments":true,"path":"2020/03/16/结合RxSwift、Moya、和HandyJSON封装网络请求模板/","link":"","permalink":"https://ifeiyv.github.io/2020/03/16/%E7%BB%93%E5%90%88RxSwift%E3%80%81Moya%E3%80%81%E5%92%8CHandyJSON%E5%B0%81%E8%A3%85%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E6%9D%BF/","excerpt":"FyNetWork 结合RxSwift、Moya、和HandyJSON封装网络请求模板 【该模板已经上传Github】-&gt; 前往Github 获取代码 文件功能Podfile123&#x2F;&#x2F;可以根据不同版本，调整库的版本（不同版本可能需要库的版本不同）pod &#39;Moya&#x2F;RxSwift&#39;, &#39;~&gt; 12.0.1&#39;pod &#39;HandyJSON&#39;, &#39;~&gt; 5.0.1&#39; FyUrls.swift主要放一些请求Url 1234567891011121314151617181920212223242526struct FyUrls &#123; &#x2F;&#x2F;&#x2F; 服务器环境 true: 正服 false: 测服 #if DEBUG &#x2F;&#x2F;测试环境 static let service: Bool &#x3D; false #else &#x2F;&#x2F;正式环境 static let service: Bool &#x3D; true #endif static var domain: String &#123; &#x2F;&#x2F; &quot;正服地址&quot; : &quot;测服地址&quot; (这里是网上搜到的开放接口，没有测试地址，两个都写正式地址) return FyUrls.service ? &quot;https:&#x2F;&#x2F;v1.alapi.cn&#x2F;&quot; : &quot;https:&#x2F;&#x2F;v1.alapi.cn&#x2F;&quot; &#125; &#x2F;&#x2F;这里写拼接到域名上的Url static var searchMusic: String &#123; return &quot;api&#x2F;music&#x2F;search&quot; &#125; &#x2F;&#x2F;....... &#125;","text":"FyNetWork 结合RxSwift、Moya、和HandyJSON封装网络请求模板 【该模板已经上传Github】-&gt; 前往Github 获取代码 文件功能Podfile123&#x2F;&#x2F;可以根据不同版本，调整库的版本（不同版本可能需要库的版本不同）pod &#39;Moya&#x2F;RxSwift&#39;, &#39;~&gt; 12.0.1&#39;pod &#39;HandyJSON&#39;, &#39;~&gt; 5.0.1&#39; FyUrls.swift主要放一些请求Url 1234567891011121314151617181920212223242526struct FyUrls &#123; &#x2F;&#x2F;&#x2F; 服务器环境 true: 正服 false: 测服 #if DEBUG &#x2F;&#x2F;测试环境 static let service: Bool &#x3D; false #else &#x2F;&#x2F;正式环境 static let service: Bool &#x3D; true #endif static var domain: String &#123; &#x2F;&#x2F; &quot;正服地址&quot; : &quot;测服地址&quot; (这里是网上搜到的开放接口，没有测试地址，两个都写正式地址) return FyUrls.service ? &quot;https:&#x2F;&#x2F;v1.alapi.cn&#x2F;&quot; : &quot;https:&#x2F;&#x2F;v1.alapi.cn&#x2F;&quot; &#125; &#x2F;&#x2F;这里写拼接到域名上的Url static var searchMusic: String &#123; return &quot;api&#x2F;music&#x2F;search&quot; &#125; &#x2F;&#x2F;....... &#125; FyApi主要放基于Moya的网络请求配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;&#x2F;&#x2F;&#x2F; FyNetworkApi.swift&#x2F;&#x2F; FyNetWork&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2020&#x2F;3&#x2F;16.&#x2F;&#x2F; Copyright © 2020 ifeiyv. All rights reserved.&#x2F;&#x2F;import Moyaenum FyApi &#123; case search(keyword:String) &#x2F;&#x2F;.... case other&#125;extension FyApi:TargetType&#123; &#x2F;&#x2F;域名配置 var baseURL: URL &#123; return URL(string: FyUrls.domain)! &#125; &#x2F;&#x2F;接口路径 var path: String &#123; switch self &#123; case .search: return FyUrls.searchMusic default: return &quot;&quot; &#125; &#125; &#x2F;&#x2F;请求的方式 可以根据接口切换请求方式 get、post或者其他 var method: Moya.Method &#123; switch self &#123; case .search: return .get default: return .post &#125; &#125; &#x2F;&#x2F;做单元测试使用的数据 var sampleData: Data &#123; return &quot;&#123;&#125;&quot;.data(using: String.Encoding.utf8)! &#125; &#x2F;&#x2F;所有要执行的接口任务，参数的配置在这里设置 var task: Task &#123; switch self &#123; case .search(let keyword): let params &#x3D; FyParams.init(params: [&quot;keyword&quot; : keyword]) return .requestParameters(parameters: params.allParams, encoding: URLEncoding.default) default: return .requestPlain &#125; &#125; &#x2F;&#x2F;默认请求头配置 &#x2F;&#x2F;也可以在FyRequest.swift的 requestTimeoutClosure中进行动态配置 var headers: [String : String]? &#123; switch self &#123; default: return [&quot;Content-type&quot;: &quot;application&#x2F;json&quot;] &#125; &#125; &#125; FyRequest.swift主要放Api接口请求方法具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;&#x2F;&#x2F;&#x2F; FyRequest.swift&#x2F;&#x2F; FyNetWork&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2020&#x2F;3&#x2F;16.&#x2F;&#x2F; Copyright © 2020 ifeiyv. All rights reserved.&#x2F;&#x2F;import UIKitimport Moyaimport RxSwiftlet requestTimeoutClosure &#x3D; &#123; (endpoint: Endpoint, done: @escaping MoyaProvider&lt;FyApi&gt;.RequestResultClosure) in do &#123; var request &#x3D; try endpoint.urlRequest() &#x2F;&#x2F;根据不同接口判断携带不同的请求头 &#x2F;&#x2F;这个也可以根据接口判断，切换超时时长 if(request.url?.absoluteString.contains(FyUrls.searchMusic.lowercased()) ?? false)&#123; request.timeoutInterval &#x3D; 30 request.addValue(&quot;zhangsan&quot;, forHTTPHeaderField: &quot;user&quot;) request.addValue(&quot;ahsfksjfhskdfhsjdkf&quot;, forHTTPHeaderField: &quot;cookie&quot;) &#125;else&#123; &#x2F;&#x2F;..... request.timeoutInterval &#x3D; 10 &#125; done(.success(request)) &#125; catch &#123; return &#125;&#125;class FyRequest: NSObject &#123; static let request &#x3D; FyRequest() var provider &#x3D; MoyaProvider&lt;FyApi&gt; (requestClosure: requestTimeoutClosure,plugins: [NetworkLoggerPlugin(verbose: true)]) &#x2F;&#x2F; var provider &#x3D; MoyaProvider&lt;FyApi&gt; ( &#x2F;&#x2F; plugins: [NetworkLoggerPlugin(verbose: false)] &#x2F;&#x2F; ) &#x2F;&#x2F;接口具体请求实现 public func searchSongs(keyword:String) -&gt; Single&lt;Result&lt;Songs&gt;&gt;&#123; return provider.rx.request(.search(keyword: keyword)) .filterSuccessfulStatusCodes() &#x2F;&#x2F;删选请求成功状态数据 .mapModel() &#x2F;&#x2F;数据模型化 .flatMap &#123; (result: FyResponse&lt;Songs&gt;) in if result.isSuccess&#123; return Single.just(Result.regular(result.data ?? Songs())) &#125;else&#123; return Single.just(Result&lt;Songs&gt;.failing(RxMoyaError.reason(result.message ?? &quot;&quot;))) &#125; &#125; .catchError(&#123; error in return Single.just(Result.failing(RxMoyaError.reason(ErrorTips.netWorkError.rawValue))) &#125;) &#125;&#125; FyResponse.swift主要是请求响应解析方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;&#x2F;&#x2F;&#x2F; FyResponse.swift&#x2F;&#x2F; FyNetWork&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2020&#x2F;3&#x2F;16.&#x2F;&#x2F; Copyright © 2020 ifeiyv. All rights reserved.&#x2F;&#x2F;import UIKitimport Moyaimport RxSwiftimport HandyJSONextension Array: HandyJSON &#123;&#125;extension String: HandyJSON &#123;&#125;&#x2F;&#x2F;采用泛型解析数据struct FyResponse&lt;T:HandyJSON&gt;:HandyJSON&#123; var code:Int &#x3D; 0 var message:String? var data: T? var isSuccess: Bool &#123; return code &#x3D;&#x3D; 200 &#125;&#125;extension Response &#123; &#x2F;&#x2F;响应数据转model func mapModel&lt;T&gt;() throws -&gt; FyResponse&lt;T&gt; &#123; do &#123; if let jsonString &#x3D; String(data: data, encoding: String.Encoding.utf8)&#123; if let obj &#x3D; JSONDeserializer&lt;FyResponse&lt;T&gt;&gt;.deserializeFrom(json: jsonString) &#123; return obj &#125; throw RxMoyaError.modelMapping(self) &#125; else &#123; throw RxMoyaError.modelMapping(self) &#125; &#125; catch &#123; throw RxMoyaError.modelMapping(self) &#125; &#125;&#125;extension PrimitiveSequence where TraitType &#x3D;&#x3D; SingleTrait, ElementType &#x3D;&#x3D; Response &#123; func mapModel&lt;T: HandyJSON&gt;() -&gt; Single&lt;FyResponse&lt;T&gt;&gt; &#123; return flatMap &#123; (response) -&gt; Single&lt;FyResponse&lt;T&gt;&gt; in return Single.just(try response.mapModel()) &#125; &#125;&#125; FyNetError.swift请求错误处理 FySongResponse.swift请求歌曲列表model例子 FyViewModel.swift网络请求库的运用例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;&#x2F;&#x2F;&#x2F; FyViewModel.swift&#x2F;&#x2F; FyNetWork&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2020&#x2F;3&#x2F;16.&#x2F;&#x2F; Copyright © 2020 ifeiyv. All rights reserved.&#x2F;&#x2F;import UIKitimport RxSwiftclass FyViewModel: NSObject &#123; var dispose &#x3D; DisposeBag() public typealias NetworkResultClosure &#x3D; (_ names:String) -&gt; Void func fetchMusicListData(keyword:String,networkResultClosure: @escaping NetworkResultClosure)&#123; _ &#x3D; FyRequest.request.searchSongs(keyword: keyword).subscribe(onSuccess: &#123; (result) in switch result&#123; case.regular(let songsInfo): var name:String &#x3D; &quot;&quot; for song in songsInfo.songs&#123; name &#x3D; name + &quot;\\n&quot; + song.name &#125; networkResultClosure(name) case .failing( _): break &#125; &#125;) &#123; (error) in &#125;.disposed(by: dispose) &#125; &#125;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ViewController.swift&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; func loadData()&#123; &#x2F;&#x2F;接口调用方式 viewModel?.fetchMusicListData(keyword:&quot;思如雪&quot;,networkResultClosure: &#123;[weak self] (names) in DispatchQueue.main.async &#123; self?.tips?.text &#x3D; names &#125; &#125;) &#125; FyParams.swift主要用来配置请求参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F;&#x2F;&#x2F; FyParams.swift&#x2F;&#x2F; Runner&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2020&#x2F;3&#x2F;16.&#x2F;&#x2F; Copyright © 2020 The Chromium Authors. All rights reserved.&#x2F;&#x2F;import UIKitclass FyBaseParams: NSObject &#123; var channel : String &#123; return &quot;com.lpf.FyNetWork&quot; &#125; var vno : Int &#123; return 100 &#125; &#x2F;&#x2F;&#x2F; ......................... &#x2F;&#x2F;这里面存放一些通用参数（也就是每个接口都要携带的参数） var baseParams:[String:Any]?&#123; var tempParams:[String:Any] &#x3D; [String:Any]() tempParams[&quot;channel&quot;] &#x3D; channel tempParams[&quot;vno&quot;] &#x3D; vno return tempParams &#125; &#x2F;&#x2F;这里存放所有请求需要的参数 var allParams:[String:Any]!&#125;&#x2F;&#x2F;根据接口需要的参数需求不同，进行适当的修改class FyParams: FyBaseParams &#123; init(params:[String:Any]? &#x3D; [String:Any]()) &#123; super.init() var tempParams &#x3D; [String:Any]() for param in baseParams ?? [String:Any]()&#123; tempParams[param.key] &#x3D; param.value &#125; for param in params ?? [String:Any]()&#123; tempParams[param.key] &#x3D; param.value &#125; allParams &#x3D; tempParams ?? [String:Any]() &#125; &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"RxSwift","slug":"RxSwift","permalink":"https://ifeiyv.github.io/tags/RxSwift/"},{"name":"Moya","slug":"Moya","permalink":"https://ifeiyv.github.io/tags/Moya/"},{"name":"HandyJSON","slug":"HandyJSON","permalink":"https://ifeiyv.github.io/tags/HandyJSON/"}]},{"title":"iOS 13 DarkMode适配","slug":"iOS 13 DarkMode适配","date":"2020-03-13T04:44:21.000Z","updated":"2020-03-17T09:03:54.212Z","comments":true,"path":"2020/03/13/iOS 13 DarkMode适配/","link":"","permalink":"https://ifeiyv.github.io/2020/03/13/iOS%2013%20DarkMode%E9%80%82%E9%85%8D/","excerpt":"","text":"封装颜色管理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#x2F;&#x2F;&#x2F;&#x2F; FyColor.swift&#x2F;&#x2F; FyColor&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2020&#x2F;3&#x2F;13.&#x2F;&#x2F; Copyright © 2020 ifeiyv. All rights reserved.&#x2F;&#x2F;import UIKitclass FyColors&#123; &#x2F;&#x2F;&#x2F;深色模式适配 手动控制适配模式 启用 关闭(如非必要，可移除相关代码) static let isOpenDarkModel:Bool &#x3D; true &#x2F;&#x2F;MARK: eg文字颜色 &#x2F;&#x2F;文字颜色 如果有多种文字颜色可以设置多个 eg: labelTextColor public class var labelTextColor: UIColor &#123; return darkModeColor(dark:UIColor.white,light:UIColor.black) &#125; &#x2F;&#x2F;文字颜色 如果有多种文字颜色可以设置多个 eg: buttonTextColor public class var buttonTextColor: UIColor &#123; return darkModeColor(dark:UIColor.white,light:UIColor.black) &#125; &#x2F;&#x2F;文字颜色 如果有多种文字颜色可以设置多个 eg: fieldTextColor public class var fieldTextColor: UIColor &#123; return darkModeColor(dark:UIColor.white,light:UIColor.black) &#125; &#x2F;&#x2F;MARK: eg背景颜色 &#x2F;&#x2F;背景颜色 如果有多种文字颜色可以设置多个 eg: labelBgColor public class var labelBgColor: UIColor &#123; return darkModeColor(dark:UIColor.black,light:UIColor.white) &#125; &#x2F;&#x2F;背景颜色 如果有多种文字颜色可以设置多个 eg: buttonBgColor public class var buttonBgColor: UIColor &#123; return darkModeColor(dark:UIColor.black,light:UIColor.white) &#125; &#x2F;&#x2F;背景颜色 如果有多种背景颜色可以设置多个 eg: viewBgColor public class var viewBgColor: UIColor &#123; return darkModeColor(dark:UIColor.black,light:UIColor.white) &#125; &#x2F;&#x2F;......................................... &#x2F;&#x2F;根据需求增加相对应的颜色即可 &#x2F;&#x2F;darkModeColor(dark:UIColor.white,light:UIColor.black) &#x2F;&#x2F;实际开发中不可能只有 UIColor.white，UIColor.black 两种颜色。 &#x2F;&#x2F;根据产品需求增加和修改对应的颜色 &#x2F;&#x2F;检测当前是否是深色模式 class func isDarkStyle() -&gt; Bool&#123; if(!isOpenDarkModel)&#123; return false &#125; if #available(iOS 13.0, *)&#123; let currentMode &#x3D; UITraitCollection.current.userInterfaceStyle if(currentMode &#x3D;&#x3D; .dark)&#123; return true &#125; &#125; return false &#125; &#x2F;&#x2F; 适配 动态颜色 class func darkModeColor(dark:UIColor,light:UIColor) -&gt;UIColor&#123; if(!isOpenDarkModel)&#123; return light &#125; if #available(iOS 13.0, *)&#123; return UIColor&#123;(trainCollection) -&gt; UIColor in if trainCollection.userInterfaceStyle &#x3D;&#x3D; .dark&#123; return dark &#125;else&#123; return light &#125; &#125; &#125; return light &#125;&#125; 使用方式：(深色模式切换时，系统会重新渲染颜色，自动在设置好的两种颜色中进行切换) 12345678label.textColor &#x3D; FyColors.labelTextColor label.backgroundColor &#x3D; FyColors.labelBgColor &#x2F;&#x2F;或者在此方法监听深色模式进行手动切换override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) &#123; super.traitCollectionDidChange(previousTraitCollection)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://ifeiyv.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/tags/Swift/"},{"name":"DarkMode","slug":"DarkMode","permalink":"https://ifeiyv.github.io/tags/DarkMode/"}]},{"title":"Swift判断字符串中是否含有中文","slug":"Swift判断字符串中是否含有中文","date":"2020-01-15T02:48:26.000Z","updated":"2020-03-17T07:32:36.467Z","comments":true,"path":"2020/01/15/Swift判断字符串中是否含有中文/","link":"","permalink":"https://ifeiyv.github.io/2020/01/15/Swift%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87/","excerpt":"","text":"123456789101112131415var str &#x3D; &quot;l我o是v中e文123456789&quot;func judgeStringIncludeChineseWord(string: String) -&gt; Bool &#123; for (_, value) in string.characters.enumerated() &#123; if (&quot;\\u&#123;4E00&#125;&quot; &lt;&#x3D; value &amp;&amp; value &lt;&#x3D; &quot;\\u&#123;9FA5&#125;&quot;) &#123; return true &#125; &#125; return false&#125;let result &#x3D; judgeStringIncludeChineseWord(string: str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"Swift字符串","slug":"Swift字符串","permalink":"https://ifeiyv.github.io/tags/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Swift 分享邀请码图片合成","slug":"Swift 分享邀请码图片合成","date":"2019-12-15T10:43:21.000Z","updated":"2020-03-17T07:29:14.331Z","comments":true,"path":"2019/12/15/Swift 分享邀请码图片合成/","link":"","permalink":"https://ifeiyv.github.io/2019/12/15/Swift%20%E5%88%86%E4%BA%AB%E9%82%80%E8%AF%B7%E7%A0%81%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/","excerpt":"","text":"1234567891011121314151617181920 class func creteImage(bgImage: UIImage, iconImage: UIImage,iconFrame:CGRect,qrCodeImage:UIImage,codeFrame:CGRect,inviteCodeImg:UIImage,frame:CGRect) -&gt; UIImage &#123; &#x2F;&#x2F; 1.开启图片上下文&#x2F;&#x2F; UIGraphicsBeginImageContext(bgImage.size) UIGraphicsBeginImageContextWithOptions(bgImage.size,false,UIScreen.main.scale) &#x2F;&#x2F; 2.绘制背景图片 bgImage.draw(in: CGRect(origin: CGPoint.zero, size: bgImage.size)) &#x2F;&#x2F; 3.绘制头像 iconImage.draw(in: iconFrame) qrCodeImage.draw(in: codeFrame) inviteCodeImg.draw(in: frame) &#x2F;&#x2F; 4.取出绘制号的图片 let newImage &#x3D; UIGraphicsGetImageFromCurrentImageContext() &#x2F;&#x2F; 5.关闭上下文 UIGraphicsEndImageContext() &#x2F;&#x2F; 6.返回合成号的图片 return newImage! &#125; 123456789101112131415161718192021222324252627282930313233343536 &#x2F;&#x2F;MARK: -传进去字符串,生成二维码图片class func setupQRCodeImage(_ text: String) -&gt; UIImage &#123; &#x2F;&#x2F;创建滤镜 let filter &#x3D; CIFilter(name: &quot;CIQRCodeGenerator&quot;) filter?.setDefaults() &#x2F;&#x2F;将url加入二维码 filter?.setValue(text.data(using: String.Encoding.utf8), forKey: &quot;inputMessage&quot;) &#x2F;&#x2F;取出生成的二维码（不清晰） if let outputImage &#x3D; filter?.outputImage &#123; &#x2F;&#x2F;生成清晰度更好的二维码 let qrCodeImage &#x3D; Util.setupHighDefinitionUIImage(outputImage, size: 140) return qrCodeImage &#125; return UIImage() &#125; &#x2F;&#x2F;MARK: - 生成高清的UIImageclass func setupHighDefinitionUIImage(_ image: CIImage, size: CGFloat) -&gt; UIImage &#123; let integral: CGRect &#x3D; image.extent.integral let proportion: CGFloat &#x3D; min(size&#x2F;integral.width, size&#x2F;integral.height) let width &#x3D; integral.width * proportion let height &#x3D; integral.height * proportion let colorSpace: CGColorSpace &#x3D; CGColorSpaceCreateDeviceGray() let bitmapRef &#x3D; CGContext(data: nil, width: Int(width), height: Int(height), bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: 0)! let context &#x3D; CIContext(options: nil) let bitmapImage: CGImage &#x3D; context.createCGImage(image, from: integral)! bitmapRef.interpolationQuality &#x3D; CGInterpolationQuality.none bitmapRef.scaleBy(x: proportion, y: proportion); bitmapRef.draw(bitmapImage, in: integral); let image: CGImage &#x3D; bitmapRef.makeImage()! return UIImage(cgImage: image) &#125; 1234567891011 class func getImageFromView(view:UIView) -&gt;UIImage&#123;&#x2F;&#x2F; UIGraphicsBeginImageContext(view.bounds.size) UIGraphicsBeginImageContextWithOptions(view.bounds.size,false,UIScreen.main.scale) view.layer.render(in: UIGraphicsGetCurrentContext()!) let image &#x3D; UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image! &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"图片合成","slug":"图片合成","permalink":"https://ifeiyv.github.io/tags/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"}]},{"title":"直播系列四、报错Bug修复记录","slug":"直播系列四、报错Bug修复记录","date":"2019-11-08T04:04:12.000Z","updated":"2020-03-17T07:52:13.197Z","comments":true,"path":"2019/11/08/直播系列四、报错Bug修复记录/","link":"","permalink":"https://ifeiyv.github.io/2019/11/08/%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E6%8A%A5%E9%94%99Bug%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/","excerpt":"","text":"./build-ffmpeg.sh 12345678xcrun -sdk iphoneos clang is unable to create an executable file.C compiler test failed.If you think configure made a mistake, make sure you are using the latestversion from Git. If the latest version fails, report the problem to theffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.Include the log file &quot;config.log&quot; produced by configure as this will helpsolve the problem. 解决方法： sudo xcode-select --switch /Applications/Xcode.app armv7 https://www.jianshu.com/p/2669370bee23 123.&#x2F;libavutil&#x2F;arm&#x2F;asm.S:50:9: error: unknown directive .arch armv7-a ^ 删除armv7compile-ffmpeg.sh文件中 123FF_ALL_ARCHS_IOS8_SDK&#x3D;&quot;armv7 arm64 i386 x86_64&quot;改为 FF_ALL_ARCHS_IOS8_SDK&#x3D;&quot;arm64 i386 x86_64&quot;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://ifeiyv.github.io/categories/iOS/"}],"tags":[{"name":"直播","slug":"直播","permalink":"https://ifeiyv.github.io/tags/%E7%9B%B4%E6%92%AD/"}]},{"title":"直播系列三、IJKPlayer拉流","slug":"直播系列三、IJKPlayer拉流","date":"2019-11-08T03:32:57.000Z","updated":"2020-03-17T07:51:00.267Z","comments":true,"path":"2019/11/08/直播系列三、IJKPlayer拉流/","link":"","permalink":"https://ifeiyv.github.io/2019/11/08/%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81IJKPlayer%E6%8B%89%E6%B5%81/","excerpt":"","text":"https://www.jianshu.com/p/65fb80dff4d6 合并真机和模拟器的framework 1lipo -create 真机framework路径 模拟器framework路径 -output 合并的文件路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import UIKitclass playerViewController: UIViewController &#123; var iPlayer:IJKFFMoviePlayerController? override func viewDidLoad() &#123; super.viewDidLoad() let options:IJKFFOptions &#x3D; IJKFFOptions.byDefault() let url:URL &#x3D; URL.init(string: &quot;rtmp:&#x2F;&#x2F;live.hkstv.hk.lxdns.com&#x2F;live&#x2F;hks&quot;)! self.iPlayer &#x3D; IJKFFMoviePlayerController.init(contentURL: url, with: options) var arm1 &#x3D; UIViewAutoresizing.init(rawValue: 0) arm1.insert(UIViewAutoresizing.flexibleWidth) arm1.insert(UIViewAutoresizing.flexibleHeight) self.iPlayer?.view.autoresizingMask &#x3D; arm1 self.iPlayer?.view.backgroundColor &#x3D; UIColor.white self.iPlayer?.view.frame &#x3D; CGRect.init(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: 300) self.iPlayer?.scalingMode &#x3D; .aspectFit self.iPlayer?.shouldAutoplay &#x3D; true self.view.autoresizesSubviews &#x3D; true self.view.addSubview((self.iPlayer?.view)!) &#x2F;&#x2F; Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#x2F;&#x2F; Dispose of any resources that can be recreated. &#125; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.iPlayer?.prepareToPlay() &#x2F;&#x2F;准备 self.iPlayer?.play() &#x2F;&#x2F;播放 &#125; override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) self.iPlayer?.pause()&#x2F;&#x2F;暂停&#x2F;&#x2F; self.iPlayer?.shutdown() &#x2F;&#x2F;销毁 &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://ifeiyv.github.io/categories/iOS/"}],"tags":[{"name":"直播","slug":"直播","permalink":"https://ifeiyv.github.io/tags/%E7%9B%B4%E6%92%AD/"}]},{"title":"直播系列二、LFLiveKit推流","slug":"直播系列二、LFLiveKit推流","date":"2019-11-08T03:05:49.000Z","updated":"2020-03-17T07:52:10.463Z","comments":true,"path":"2019/11/08/直播系列二、LFLiveKit推流/","link":"","permalink":"https://ifeiyv.github.io/2019/11/08/%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97%E4%BA%8C%E3%80%81LFLiveKit%E6%8E%A8%E6%B5%81/","excerpt":"","text":"LFLiveKit：框架支持RTMP，由Adobe公司开发。github地址https://github.com/LaiFengiOS/LFLiveKit LFLiveKit库里已经集成GPUImage框架用于美颜功能，GPUImage基于OpenGl开发，纯OC语言框架，封装好了各种滤镜同时也可以编写自定义的滤镜，其本身内置了多达125种常见的滤镜效果。 LFLiveKit库通过pod导入项目 pod &apos;LFLiveKit&apos;配置上传地址 123let stream &#x3D; LFLiveStreamInfo()stream.url &#x3D; &quot;rtmp:&#x2F;&#x2F;192.168.***.***:1935&#x2F;rtmplive&#x2F;room&quot;session.startLive(stream) demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426//// ViewController.swift// IfeiyvLiveVideo//// Created by l on 2019/7/1.// Copyright © 2019 ifeiyv. All rights reserved.//import UIKitclass ViewController: UIViewController, LFLiveSessionDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. session.delegate = self session.preView = self.view self.requestAccessForVideo() self.requestAccessForAudio() self.view.backgroundColor = UIColor.clear self.view.addSubview(containerView) containerView.addSubview(stateLabel) containerView.addSubview(closeButton) containerView.addSubview(beautyButton) containerView.addSubview(cameraButton) containerView.addSubview(startLiveButton) cameraButton.addTarget(self, action: #selector(didTappedCameraButton(_:)), for:.touchUpInside) beautyButton.addTarget(self, action: #selector(didTappedBeautyButton(_:)), for: .touchUpInside) startLiveButton.addTarget(self, action: #selector(didTappedStartLiveButton(_:)), for: .touchUpInside) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //MARK: AccessAuth func requestAccessForVideo() -&gt; Void &#123; let status = AVCaptureDevice.authorizationStatus(for: AVMediaType.video); switch status &#123; // 许可对话没有出现，发起授权许可 case AVAuthorizationStatus.notDetermined: AVCaptureDevice.requestAccess(for: AVMediaType.video, completionHandler: &#123; (granted) in if(granted)&#123; DispatchQueue.main.async &#123; self.session.running = true &#125; &#125; &#125;) break; // 已经开启授权，可继续 case AVAuthorizationStatus.authorized: session.running = true; break; // 用户明确地拒绝授权，或者相机设备无法访问 case AVAuthorizationStatus.denied: break case AVAuthorizationStatus.restricted:break; default: break; &#125; &#125; func requestAccessForAudio() -&gt; Void &#123; let status = AVCaptureDevice.authorizationStatus(for:AVMediaType.audio) switch status &#123; // 许可对话没有出现，发起授权许可 case AVAuthorizationStatus.notDetermined: AVCaptureDevice.requestAccess(for: AVMediaType.audio, completionHandler: &#123; (granted) in &#125;) break; // 已经开启授权，可继续 case AVAuthorizationStatus.authorized: break; // 用户明确地拒绝授权，或者相机设备无法访问 case AVAuthorizationStatus.denied: break case AVAuthorizationStatus.restricted:break; default: break; &#125; &#125; //MARK: - Callbacks // 回调 func liveSession(_ session: LFLiveSession?, debugInfo: LFLiveDebug?) &#123; print(\"debugInfo: \\(debugInfo?.currentBandwidth)\") &#125; func liveSession(_ session: LFLiveSession?, errorCode: LFLiveSocketErrorCode) &#123; print(\"errorCode: \\(errorCode.rawValue)\") &#125; func liveSession(_ session: LFLiveSession?, liveStateDidChange state: LFLiveState) &#123; print(\"liveStateDidChange: \\(state.rawValue)\") switch state &#123; case LFLiveState.ready: stateLabel.text = \"未连接\" break; case LFLiveState.pending: stateLabel.text = \"连接中\" break; case LFLiveState.start: stateLabel.text = \"已连接\" break; case LFLiveState.error: stateLabel.text = \"连接错误\" break; case LFLiveState.stop: stateLabel.text = \"未连接\" break; default: break; &#125; &#125; //MARK: - Events // 开始直播 @objc func didTappedStartLiveButton(_ button: UIButton) -&gt; Void &#123; startLiveButton.isSelected = !startLiveButton.isSelected; if (startLiveButton.isSelected) &#123; startLiveButton.setTitle(\"结束直播\", for: UIControl.State()) let stream = LFLiveStreamInfo() stream.url = \"rtmp://192.168.1.148:1935/rtmplive/room\" session.startLive(stream) &#125; else &#123; startLiveButton.setTitle(\"开始直播\", for: UIControl.State()) session.stopLive() &#125; &#125; // 美颜 @objc func didTappedBeautyButton(_ button: UIButton) -&gt; Void &#123; session.beautyFace = !session.beautyFace; beautyButton.isSelected = !session.beautyFace &#125; // 摄像头 @objc func didTappedCameraButton(_ button: UIButton) -&gt; Void &#123; let devicePositon = session.captureDevicePosition; session.captureDevicePosition = (devicePositon == AVCaptureDevice.Position.back) ? AVCaptureDevice.Position.front : AVCaptureDevice.Position.back; &#125; // 关闭 func didTappedCloseButton(_ button: UIButton) -&gt; Void &#123; &#125; //MARK: - Getters and Setters // 默认分辨率368 ＊ 640 音频：44.1 iphone6以上48 双声道 方向竖屏 var session: LFLiveSession = &#123; let audioConfiguration = LFLiveAudioConfiguration.defaultConfiguration(for: LFLiveAudioQuality.high) let videoConfiguration = LFLiveVideoConfiguration.defaultConfiguration(for: LFLiveVideoQuality.low3) let session = LFLiveSession(audioConfiguration: audioConfiguration, videoConfiguration: videoConfiguration) return session! &#125;() // 视图 var containerView: UIView = &#123; let containerView = UIView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height)) containerView.backgroundColor = UIColor.clear containerView.autoresizingMask = [UIView.AutoresizingMask.flexibleHeight, UIView.AutoresizingMask.flexibleHeight] return containerView &#125;() // 状态Label var stateLabel: UILabel = &#123; let stateLabel = UILabel(frame: CGRect(x: 20, y: 20, width: 80, height: 40)) stateLabel.text = \"未连接\" stateLabel.textColor = UIColor.white stateLabel.font = UIFont.systemFont(ofSize: 14) return stateLabel &#125;() // 关闭按钮 var closeButton: UIButton = &#123; let closeButton = UIButton(frame: CGRect(x: UIScreen.main.bounds.width - 10 - 44, y: 20, width: 44, height: 44)) closeButton.setImage(UIImage(named: \"close_preview\"), for: UIControl.State()) return closeButton &#125;() // 摄像头 var cameraButton: UIButton = &#123; let cameraButton = UIButton(frame: CGRect(x: UIScreen.main.bounds.width - 54 * 2, y: 20, width: 44, height: 44)) cameraButton.setImage(UIImage(named: \"camra_preview\"), for: UIControl.State()) return cameraButton &#125;() // 摄像头 var beautyButton: UIButton = &#123; let beautyButton = UIButton(frame: CGRect(x: UIScreen.main.bounds.width - 54 * 3, y: 20, width: 44, height: 44)) beautyButton.setImage(UIImage(named: \"camra_beauty\"), for: UIControl.State.selected) beautyButton.setImage(UIImage(named: \"camra_beauty_close\"), for: UIControl.State()) return beautyButton &#125;() // 开始直播按钮 var startLiveButton: UIButton = &#123; let startLiveButton = UIButton(frame: CGRect(x: 30, y: UIScreen.main.bounds.height - 50, width: UIScreen.main.bounds.width - 10 - 44, height: 44)) startLiveButton.layer.cornerRadius = 22 startLiveButton.setTitleColor(UIColor.black, for:UIControl.State()) startLiveButton.setTitle(\"开始直播\", for: UIControl.State()) startLiveButton.titleLabel!.font = UIFont.systemFont(ofSize: 14) startLiveButton.backgroundColor = UIColor(red: 50/255.0, green: 32/255.0, blue: 245/255.0, alpha: 1)//colorLiteralRed: 50, green: 32, blue: 245, alpha: 1 return startLiveButton &#125;()&#125;//// ViewController.swift// IfeiyvLiveVideo//// Created by l on 2019/7/1.// Copyright © 2019 ifeiyv. All rights reserved.//import UIKitclass ViewController: UIViewController, LFLiveSessionDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. session.delegate = self session.preView = self.view self.requestAccessForVideo() self.requestAccessForAudio() self.view.backgroundColor = UIColor.clear self.view.addSubview(containerView) containerView.addSubview(stateLabel) containerView.addSubview(closeButton) containerView.addSubview(beautyButton) containerView.addSubview(cameraButton) containerView.addSubview(startLiveButton) cameraButton.addTarget(self, action: #selector(didTappedCameraButton(_:)), for:.touchUpInside) beautyButton.addTarget(self, action: #selector(didTappedBeautyButton(_:)), for: .touchUpInside) startLiveButton.addTarget(self, action: #selector(didTappedStartLiveButton(_:)), for: .touchUpInside) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //MARK: AccessAuth func requestAccessForVideo() -&gt; Void &#123; let status = AVCaptureDevice.authorizationStatus(for: AVMediaType.video); switch status &#123; // 许可对话没有出现，发起授权许可 case AVAuthorizationStatus.notDetermined: AVCaptureDevice.requestAccess(for: AVMediaType.video, completionHandler: &#123; (granted) in if(granted)&#123; DispatchQueue.main.async &#123; self.session.running = true &#125; &#125; &#125;) break; // 已经开启授权，可继续 case AVAuthorizationStatus.authorized: session.running = true; break; // 用户明确地拒绝授权，或者相机设备无法访问 case AVAuthorizationStatus.denied: break case AVAuthorizationStatus.restricted:break; default: break; &#125; &#125; func requestAccessForAudio() -&gt; Void &#123; let status = AVCaptureDevice.authorizationStatus(for:AVMediaType.audio) switch status &#123; // 许可对话没有出现，发起授权许可 case AVAuthorizationStatus.notDetermined: AVCaptureDevice.requestAccess(for: AVMediaType.audio, completionHandler: &#123; (granted) in &#125;) break; // 已经开启授权，可继续 case AVAuthorizationStatus.authorized: break; // 用户明确地拒绝授权，或者相机设备无法访问 case AVAuthorizationStatus.denied: break case AVAuthorizationStatus.restricted:break; default: break; &#125; &#125; //MARK: - Callbacks // 回调 func liveSession(_ session: LFLiveSession?, debugInfo: LFLiveDebug?) &#123; print(\"debugInfo: \\(debugInfo?.currentBandwidth)\") &#125; func liveSession(_ session: LFLiveSession?, errorCode: LFLiveSocketErrorCode) &#123; print(\"errorCode: \\(errorCode.rawValue)\") &#125; func liveSession(_ session: LFLiveSession?, liveStateDidChange state: LFLiveState) &#123; print(\"liveStateDidChange: \\(state.rawValue)\") switch state &#123; case LFLiveState.ready: stateLabel.text = \"未连接\" break; case LFLiveState.pending: stateLabel.text = \"连接中\" break; case LFLiveState.start: stateLabel.text = \"已连接\" break; case LFLiveState.error: stateLabel.text = \"连接错误\" break; case LFLiveState.stop: stateLabel.text = \"未连接\" break; default: break; &#125; &#125; //MARK: - Events // 开始直播 @objc func didTappedStartLiveButton(_ button: UIButton) -&gt; Void &#123; startLiveButton.isSelected = !startLiveButton.isSelected; if (startLiveButton.isSelected) &#123; startLiveButton.setTitle(\"结束直播\", for: UIControl.State()) let stream = LFLiveStreamInfo() stream.url = \"rtmp://192.168.1.148:1935/rtmplive/room\" session.startLive(stream) &#125; else &#123; startLiveButton.setTitle(\"开始直播\", for: UIControl.State()) session.stopLive() &#125; &#125; // 美颜 @objc func didTappedBeautyButton(_ button: UIButton) -&gt; Void &#123; session.beautyFace = !session.beautyFace; beautyButton.isSelected = !session.beautyFace &#125; // 摄像头 @objc func didTappedCameraButton(_ button: UIButton) -&gt; Void &#123; let devicePositon = session.captureDevicePosition; session.captureDevicePosition = (devicePositon == AVCaptureDevice.Position.back) ? AVCaptureDevice.Position.front : AVCaptureDevice.Position.back; &#125; // 关闭 func didTappedCloseButton(_ button: UIButton) -&gt; Void &#123; &#125; //MARK: - Getters and Setters // 默认分辨率368 ＊ 640 音频：44.1 iphone6以上48 双声道 方向竖屏 var session: LFLiveSession = &#123; let audioConfiguration = LFLiveAudioConfiguration.defaultConfiguration(for: LFLiveAudioQuality.high) let videoConfiguration = LFLiveVideoConfiguration.defaultConfiguration(for: LFLiveVideoQuality.low3) let session = LFLiveSession(audioConfiguration: audioConfiguration, videoConfiguration: videoConfiguration) return session! &#125;() // 视图 var containerView: UIView = &#123; let containerView = UIView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height)) containerView.backgroundColor = UIColor.clear containerView.autoresizingMask = [UIView.AutoresizingMask.flexibleHeight, UIView.AutoresizingMask.flexibleHeight] return containerView &#125;() // 状态Label var stateLabel: UILabel = &#123; let stateLabel = UILabel(frame: CGRect(x: 20, y: 20, width: 80, height: 40)) stateLabel.text = \"未连接\" stateLabel.textColor = UIColor.white stateLabel.font = UIFont.systemFont(ofSize: 14) return stateLabel &#125;() // 关闭按钮 var closeButton: UIButton = &#123; let closeButton = UIButton(frame: CGRect(x: UIScreen.main.bounds.width - 10 - 44, y: 20, width: 44, height: 44)) closeButton.setImage(UIImage(named: \"close_preview\"), for: UIControl.State()) return closeButton &#125;() // 摄像头 var cameraButton: UIButton = &#123; let cameraButton = UIButton(frame: CGRect(x: UIScreen.main.bounds.width - 54 * 2, y: 20, width: 44, height: 44)) cameraButton.setImage(UIImage(named: \"camra_preview\"), for: UIControl.State()) return cameraButton &#125;() // 摄像头 var beautyButton: UIButton = &#123; let beautyButton = UIButton(frame: CGRect(x: UIScreen.main.bounds.width - 54 * 3, y: 20, width: 44, height: 44)) beautyButton.setImage(UIImage(named: \"camra_beauty\"), for: UIControl.State.selected) beautyButton.setImage(UIImage(named: \"camra_beauty_close\"), for: UIControl.State()) return beautyButton &#125;() // 开始直播按钮 var startLiveButton: UIButton = &#123; let startLiveButton = UIButton(frame: CGRect(x: 30, y: UIScreen.main.bounds.height - 50, width: UIScreen.main.bounds.width - 10 - 44, height: 44)) startLiveButton.layer.cornerRadius = 22 startLiveButton.setTitleColor(UIColor.black, for:UIControl.State()) startLiveButton.setTitle(\"开始直播\", for: UIControl.State()) startLiveButton.titleLabel!.font = UIFont.systemFont(ofSize: 14) startLiveButton.backgroundColor = UIColor(red: 50/255.0, green: 32/255.0, blue: 245/255.0, alpha: 1)//colorLiteralRed: 50, green: 32, blue: 245, alpha: 1 return startLiveButton &#125;()&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://ifeiyv.github.io/categories/iOS/"}],"tags":[{"name":"直播","slug":"直播","permalink":"https://ifeiyv.github.io/tags/%E7%9B%B4%E6%92%AD/"}]},{"title":"直播系列一、创建本地rtmp服务器","slug":"直播系列一、创建本地rtmp服务器","date":"2019-11-08T02:32:25.000Z","updated":"2020-03-17T07:57:22.835Z","comments":true,"path":"2019/11/08/直播系列一、创建本地rtmp服务器/","link":"","permalink":"https://ifeiyv.github.io/2019/11/08/%E7%9B%B4%E6%92%AD%E7%B3%BB%E5%88%97%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0rtmp%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"在网上搜索参考了大量文章，解决了N多Bug,终于实现了直播功能 nginx是非常优秀的开源服务器，用它来做hls或者rtmp流媒体服务器是非常不错的选择 1、安装Homebrow（1）执行克隆命令,github的项目(https://github.com/denji/homebrew-nginx) brew tap denji/nginx 注意brew tap homebrew/nginx报下面的错误,homebrew/nginx已经弃用. 报错：Error: homebrew/nginx was deprecated. This tap is now empty as all its formulae were migrated. （2）执行安装命令: brew install nginx-full --with-rtmp-module （3）至此nginx和rtmp模块就安装好了，下面开始来配置nginx的rtmp模块 接下来看一下nginx安装在什么地方: brew info nginx-full 打印信息 12345678910111213141516171819202122The default port has been set in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;.- Tips -Run port 80: $ sudo chown root:wheel &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx-full&#x2F;bin&#x2F;nginx $ sudo chmod u+s &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx-full&#x2F;bin&#x2F;nginxReload config: $ nginx -s reloadReopen Logfile: $ nginx -s reopenStop process: $ nginx -s stopWaiting on exit process $ nginx -s quitTo have launchd start denji&#x2F;nginx&#x2F;nginx-full now and restart at login: brew services start denji&#x2F;nginx&#x2F;nginx-fullOr, if you don&#39;t want&#x2F;need a background service you can just run: nginx nginx安装所在位置: /usr/local/opt/nginx-full/bin/nginxnginx配置文件所在位置: /usr/local/etc/nginx/nginx.conf（4）启动nginx,执行命令: sudo nginx2、测试nginx：在浏览器中打开如下地址：http://localhost:8080入过如果出现Welcome to nginx!,说明安装成功. 如果终端上提示： nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use) 则表示8080端口被占用了, 查看端口PID lsof -i tcp:8080 kill掉占用8080端口的PID kill 9603（这里替换成占用8080端口的PID） 3、重新加载nginx的配置文件（1）修改nginx.conf这个配置文件，配置rtmp 复制nginx配置文件所在位置: vi /usr/local/etc/nginx/nginx.conf （2）执行上面命令会直接编辑,或者直接前往当前文件用记事本打开. 滚动到最后面(最后一个}后面即可，不能在{}里面)，添加一下代码，进行配置，最后记得保存。 1234567891011121314151617rtmp &#123; server &#123; listen 1935; #直播流配置 application rtmplive &#123; live on; #为 rtmp 引擎设置最大连接数。默认为 off max_connections 1024; &#125; application hls&#123; live on; hls on; hls_path &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;hls; hls_fragment 1s; &#125; &#125; &#125; （3）编辑完成之后,执行一下重新加载配置文件命令: sudo nginx -s reload 需要输入开机密码 sudo不加的话会报错： nginx: [alert] could not open error log file: open() &quot;/usr/local/var/log/nginx/error.log&quot; failed (13: Permission denied)该命令执行后会出来一个弹框询问是否允许 nginx 加入到网络中，选择允许即可。 （4）重启nginx： sudo /usr/local/opt/nginx-full/bin/nginx -s reload PS：如果你之前不是按照我上面的方法按照的 nginx，在执行 sudo nginx -s reload 时报了如下错，建议你卸载 nginx后按照我上面的步骤重新安装nginx。 nginx: [emerg] unknown directive “rtmp” in /usr/local/etc/nginx/nginx.conf:119 nginx常用方法: 出现权限不足的错误提示时，命令前加上 sudo 1234重新加载配置文件: nginx -s reload重新加载日志: nginx -s reopen 停止 nginx: nginx -s stop 有序退出 nginx: nginx -s quit 4、安装ffmepg工具brew install ffmpeg5、本地推流(1)、搭建本地视频直播，比如电脑上面有很多电影，我们可以通过推流的形式实现实时直播： A：在电脑上播放推流内容 安装一个支持rtmp协议的视频播放器，Mac下可以用VLC 下载VLC 本地下载一个视频文件路径为 /Users/iOS002/Desktop/loginmovie.mp4 执行以下命令: ffmpeg -re -i /Users/iOS002/Desktop/loginmovie.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmplive/room用vlc 然后打开 VLC 中 的 file – Open Network, 直接输入代码中的 url: rtmp://localhost:1935/rtmplive/room即可以通过VLC来播放终端中实时推过来的 RTMP流。 B：通过手机观看电脑的推流 通过集成 ijkplayer 把地址换成推流的地址即可观看 播放端用的针对RTMP优化过的ijkplayer，ijkplayer是基于FFmpeg的跨平台播放器，这个开源项目已经被多个 App 使用，其中映客、美拍和斗鱼使用了 ijkplayer。 (2)、桌面录制或者分享 ffmpeg -f avfoundation -i &quot;1&quot; -vcodec libx264 -preset ultrafast -acodec libfaac -f flv rtmp://localhost:1935/rtmplive/room (3)、桌面+麦克风 ffmpeg -f avfoundation -i &quot;1:0&quot; -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1935/rtmplive/room(4)、桌面+麦克风，并且还要摄像头拍摄到自己 ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; \\-f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; \\-c:v libx264 -preset ultrafast \\-filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:2016/rtmplive/room 6、手机推流可以用 LFLiveKit 集成到工程进行推流，LFLiveKit已经帮我们实现了视频采集、后台录制、美颜功能、支持h264、AAC编码，动态改变速率，RTMP传输等，我们开发的时候就很简单了只需把localhost:8080换成自己电脑的ip地址即可: rtmp://10.0.0.17:1935/rtmplive/room注意通过网络查看电脑的局域网 IP替换掉 localhost 即可。 A：通过VLC观看手机的推流 打开手机直播后，然后在电脑上打开VLC（同上），就能实现手机推流，在电脑上拉流播放了！！(注：手机需要和电脑连接同一网络！) B：通过手机观看手机的推流（这也就是市面上的那些直播App的最终实现形式了） 通过集成 ijkplayer 把地址换成推流的地址即可观看。 PS：一个很隐蔽的报错： 如果你发现你的推流地址和拉流地址在电脑上都是好好的，但是通过手机实现的时候就是报错，那么估计就是因为Mac防火墙的问题。 1234ERROR: PILI_RTMP_Connect0, failed to connect socket. 60 (Operation timed out)ERROR: WriteN, PILI_RTMP send error 9, Bad file descriptor, (140 bytes)ERROR: PILI_RTMP_Connect0, failed to connect socket. 60 (Operation timed out)ERROR: WriteN, PILI_RTMP send error 9, Bad file descriptor, (140 bytes) 关闭 Mac 的防火墙即可解决问题。 偏好设置-&gt;安全性与隐私-&gt;防火墙","categories":[{"name":"iOS","slug":"iOS","permalink":"https://ifeiyv.github.io/categories/iOS/"}],"tags":[{"name":"直播","slug":"直播","permalink":"https://ifeiyv.github.io/tags/%E7%9B%B4%E6%92%AD/"}]},{"title":"shared_preferences数据存储","slug":"shared_preferences数据存储","date":"2019-10-19T10:52:45.000Z","updated":"2020-03-17T07:24:36.521Z","comments":true,"path":"2019/10/19/shared_preferences数据存储/","link":"","permalink":"https://ifeiyv.github.io/2019/10/19/shared_preferences%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","excerpt":"","text":"shared_preferences库 shared_preferences库同时支持Android和ios平台,存键值对信息，进行数据本地持久化存储。 引用方法 在pubspec.yaml文件中添加依赖 shared_preferences: ^0.5.3+4-&gt;查看最新版本 执行$ flutter packages get命令 下载插件 在使用的文件中导入： import &#39;package:shared_preferences/shared_preferences.dart&#39;; 使用方法12345678910111213141516171819202122232425262728293031323334353637SharedPreferences sharedPreferences &#x3D; await SharedPreferences.getInstance();sharedPreferences.setString(&quot;name&quot;, &quot;hehe&quot;);sharedPreferences.setInt(&quot;age&quot;, 18);sharedPreferences.setDouble(&quot;height&quot;, 1.72);sharedPreferences.setBool(&quot;sex&quot;, true);&#x2F;&#x2F;true 表示男 false表示女sharedPreferences.setStringList(&quot;like&quot;, [&quot;MV&quot;,&quot;Music&quot;,&quot;Pic&quot;]);print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;get****(&quot;key&quot;)取出存储的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);print(&quot;姓名:&quot;+ sharedPreferences.getString(&quot;name&quot;));print(&quot;年龄:&quot; + sharedPreferences.getInt(&quot;age&quot;).toString());print(&quot;身高:&quot;+ sharedPreferences.getDouble(&quot;height&quot;).toString());print(&quot;性别:&quot;+ ((sharedPreferences.getBool(&quot;sex&quot;) &#x3D;&#x3D; true) ? &quot;男&quot;:&quot;女&quot;));print(&quot;爱好:&quot;+ sharedPreferences.getStringList(&quot;like&quot;).toString());print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;getKeys()取出存储的所有key值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);print(sharedPreferences.getKeys());print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;set***(&quot;key&quot;)给已经存在的key重新赋值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);print(&quot;姓名:&quot;+ sharedPreferences.getString(&quot;name&quot;));sharedPreferences.setString(&quot;name&quot;, &quot;feiyv&quot;);print(&quot;姓名:&quot;+ sharedPreferences.getString(&quot;name&quot;));print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;containsKey(&quot;key&quot;)判断存储的是否有某个Key值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);print(&quot;name是否存在：&quot; + sharedPreferences.containsKey(&quot;name&quot;));print(&quot;rename是否存在：&quot; + sharedPreferences.containsKey(&quot;rename&quot;));print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;remove(&quot;key&quot;)删除单个Key数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);print(&quot;年龄:&quot; + sharedPreferences.getInt(&quot;age&quot;).toString());sharedPreferences.remove(&quot;age&quot;);print(&quot;年龄:&quot; + sharedPreferences.getInt(&quot;age&quot;).toString());print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;clear清除所有数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);sharedPreferences.clear();print(&quot;sharedPreferences.clear();&quot;);print(&quot;name是否存在：&quot; + sharedPreferences.containsKey(&quot;name&quot;).toString());print(&quot;所有的key值：&quot;+ sharedPreferences.getKeys().toString()); 打印数据：123456789101112131415161718192021222324252627flutter: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;get****(&quot;key&quot;)取出存储的数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flutter: 姓名:heheflutter: 年龄:18flutter: 身高:1.72flutter: 性别:男flutter: 爱好:[MV, Music, Pic]flutter: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;getKeys()取出存储的所有key值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flutter: &#123;name, age, height, sex, like&#125;flutter: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;set****(&quot;key&quot;)给已经存在的key重新赋值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flutter: 姓名:heheflutter: 姓名:feiyvflutter: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;containsKey(&quot;key&quot;)判断存储的是否有某个Key值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flutter: name是否存在：trueflutter: rename是否存在：falseflutter: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;remove(&quot;key&quot;)删除单个Key数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flutter: 年龄:18flutter: 年龄:nullflutter: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;clear清除所有数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;flutter: sharedPreferences.clear();flutter: name是否存在：falseflutter: 所有的key值：&#123;&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"shared_preferences","slug":"shared-preferences","permalink":"https://ifeiyv.github.io/tags/shared-preferences/"}]},{"title":"path_provider获取系统目录","slug":"path_provider获取系统目录","date":"2019-10-13T07:22:25.000Z","updated":"2020-03-17T07:23:31.912Z","comments":true,"path":"2019/10/13/path_provider获取系统目录/","link":"","permalink":"https://ifeiyv.github.io/2019/10/13/path_provider%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/","excerpt":"","text":"PathProvider 插件 PathProvider 访问设备文件系统上的常用位置。 使用方法： 在pubspec.yaml文件中添加 PathProvider 插件 path_provider: ^*.*.*查看最新版本 在文件中导入： import &#39;package:path_provider/path_provider.dart&#39;; DocumentsDirectory 文档目录，用于存储只有自己可以访问的文件。只有当应用程序被卸载时，系统才会清除该目录。在iOS上，这对应于NSDocumentDirectory。在Android上，这是AppData目录。 String docDir = (await getApplicationDocumentsDirectory()).path; TemporaryDirectory 系统可随时清除的临时目录（缓存）。在iOS上，这对应于NSTemporaryDirectory() 返回的值。在Android上，这是getCacheDir()返回的目录。 String tempDir = (await getTemporaryDirectory()).path; SupportDirectory 在iOS上，它使用NSApplicationSupportDirectory 来获取目录。在Android上，这是getFilesDir返回的目录。 String supportDir = (await getApplicationSupportDirectory()).path; ExternalStorageDirectory 获取存储卡路径,仅在Android上中有效，iOS系统无此方法，可以通过Platform.isIOS来判断当前系统是否是iOS系统 String extStorageDir = (await getExternalStorageDirectory()).path; PathProvider-&gt;GitHub PathProvider-&gt;Pub","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"path_provider","slug":"path-provider","permalink":"https://ifeiyv.github.io/tags/path-provider/"}]},{"title":"Flutter开发之Text Widget","slug":"Flutter开发之Text Widget","date":"2019-08-21T13:43:55.000Z","updated":"2020-03-17T07:18:17.340Z","comments":true,"path":"2019/08/21/Flutter开发之Text Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/21/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BText%20Widget/","excerpt":"","text":"Text Widget “文本”小组件显示单个样式的文本字符串。字符串可能会跨越多行，也可能全部显示在同一行上，具体取决于布局约束。 1234567891011Text( &#x2F;&#x2F;显示的文本 &#39;Hello, $_name! How are you?&#39;, &#x2F;&#x2F;对齐的方式 textAlign: TextAlign.center, overflow: TextOverflow.ellipsis, &#x2F;&#x2F;文本样式 style: TextStyle(fontWeight: FontWeight.bold),) 下面使用Text.rich构造函数，Text小部件可以显示具有不同样式TextSpans的段落。下面的示例显示每个单词具有不同样式的“Hello beautiful world”。 123456789const Text.rich( TextSpan( text: &#39;Hello&#39;, &#x2F;&#x2F; default text style children: &lt;TextSpan&gt;[ TextSpan(text: &#39; beautiful &#39;, style: TextStyle(fontStyle: FontStyle.italic)), TextSpan(text: &#39;world&#39;, style: TextStyle(fontWeight: FontWeight.bold)), ], ),) 交互要使Text对触摸事件做出反应，请使用GestureDetector.onTap处理程序将其包装在GestureDetector小部件中。 在材料设计应用程序中，请考虑使用FlatButton，或者如果不合适，至少使用InkWell而不是GestureDetector。 要使文本的各个部分具有交互性，请使用RichText并将TapGestureRecognizer指定为文本相关部分的TextSpan.recognizer。 RichText，它可以让您更好地控制文本样式。DefaultTextStyle，用于设置Text小部件的默认样式。 构造方法1234567891011121314 Text(String data, &#123; Key key, TextStyle style, StrutStyle strutStyle, TextAlign textAlign, TextDirection textDirection, Locale locale, bool softWrap, TextOverflow overflow, double textScaleFactor, int maxLines, String semanticsLabel &#125;) 1234567891011121314Text.rich(TextSpan textSpan, &#123; Key key, TextStyle style, StrutStyle strutStyle, TextAlign textAlign, TextDirection textDirection, Locale locale, bool softWrap, TextOverflow overflow, double textScaleFactor, int maxLines, String semanticsLabel &#125;) 属性 data → String 要显示的文字 locale → Locale 用于在可以以不同方式呈现相同Unicode字符时选择字体，具体取决于区域设置 很少需要设置此属性。默认情况下，其值继承自包含Localizations.localeOf（context）的应用程序 有关更多信息，请参见RenderParagraph.locale。 maxLines→int 文本要跨越的可选最大行数，必要时包装。如果文本超过给定的行数，则会根据溢出将其截断 overflow→TextOverflow 如何处理视觉溢出 TextOverflow枚举 clip→const TextOverflow剪切溢出的文本以修复其容器。const TextOverflow（0） ellipsis→const TextOverflow将溢出的文本淡化为透明。const TextOverflow（1） ellipsis→const TextOverflow使用省略号表示文本已溢出。const TextOverflow（2） visible→const TextOverflow在其容器外部渲染溢出的文本。const TextOverflow（3） values→const List 此枚举中值的常量列表，按其声明顺序排列。const List semanticsLabel→String 此文本的替代语义标签 如果存在, 这个小部件的语义将包含此值, 而不是实际的文本。这将覆盖任何直接应用于 TextSpans 的语义标签 这对于用全文值替换缩写或短文很有用: Text(r&#39;$$&#39;, semanticsLabel: &#39;Double dollars&#39;) softWrap→bool 文本是否应该在软换行符处中断 如果是false, 文本中的字形将被定位为无限的水平空间 strutStyle→StrutStyle 要使用的strut风格。 Strut样式定义了strut，它设置了最小垂直布局度量 允许省略或提供 null 将禁用strut. 为 StrutStyle 的任何属性提供 null 将导致使用默认值 强烈建议至少指定一个字体. 有关详细信息, 请参见 StrutStyle。 eg: 123456789101112 const Text( &#39;Hello, world!\\nSecond line!&#39;, style: TextStyle( fontSize: 10, fontFamily: &#39;Raleway&#39;, ), strutStyle: StrutStyle( fontFamily: &#39;Roboto&#39;, fontSize: 30, height: 1.5, ),), style→TextStyle 如果为非null，则为此文本使用的样式 如果样式的 “继承” 属性为 true, 则该样式将与最接近的封闭默认文本样式合并 否则, 该样式将替换最接近的封闭的默认文本样式 textAlign→TextAlign 文本应如何水平对齐 TextAlign 枚举 left → const TextAlign 文本左对齐 const TextAlign(0) right → const TextAlign 文本右对齐 const TextAlign(1) center→ const TextAlign 文本中心对齐 const TextAlign(2) justify → const TextAlign 拉伸以柔和的换行符结束的文本行, 以填充容器的宽度. 以硬线符结束的线条与起始边缘对齐。const TextAlign(3) start → const TextAlign 文本开始处对齐 从左到右即为左边，从右到左即为右边 const TextAlign(4) end → const TextAlign 文本结束处对齐 从左到右即为右边，从右到左即为左边 const TextAlign(5) values → const List 此枚举中值的常量列表，按其声明顺序排列。 textDirection→TextDirection 文本的方向性 这也就解释为什么出现TextAlign.start和TextAlign.end等textAlign值 eg: 例如，如果数据是英语短语后跟希伯来语短语，则在TextDirection.ltr上下文中，英语短语将位于左侧，希伯来语短语位于其右侧，而在TextDirection.rtl上下文中，英语短语将 在右边，左边是希伯来语。 textScaleFactor→double 每个逻辑像素的字体像素数 例如，如果文本比例因子为1.5，则文本将比指定的字体大小大50％ 作为textScaleFactor赋予构造函数的值。 如果为null，将使用从环境MediaQuery获取的MediaQueryData.textScaleFactor，如果范围内没有MediaQuery，则使用1.0。 textSpan→TextSpan 要显示为TextSpan的文本 hashCode→int 此对象的哈希码 key→Key 控制一个小部件如何替换树中的另一个小部件 runtimeType→Type 表示对象的运行时类型 方法 build（BuildContext context）→Widget 描述此窗口小部件表示的用户界面部分 debugFillProperties（DiagnosticPropertiesBuilder properties）→void 添加与节点关联的其他属性 createElement（）→StatelessElement 创建StatelessElement以管理此窗口小部件在树中的位置。 […] debugDescribeChildren（）→ List 返回描述此节点的子节点的DiagnosticsNode对象列表。 […] noSuchMethod（Invocation invocation）→dynamic 访问不存在的方法或属性时调用。 […] toDiagnosticsNode（{String name，DiagnosticsTreeStyle style}）→DiagnosticsNode 返回调试工具和DiagnosticsNode.toStringDeep使用的对象的调试表示形式。 […] toString（{DiagnosticLevel minLevel：DiagnosticLevel.debug}）→字符串 返回此对象的字符串表示形式 toStringDeep（{String prefixLineOne：’’，String prefixOtherLines，DiagnosticLevel minLevel：DiagnosticLevel.debug}）→String 返回此节点及其后代的字符串表示形式。 […] toStringShallow（{String joiner：’，’，DiagnosticLevel minLevel：DiagnosticLevel.debug}）→String 返回对象的单行详细描述。 […] toStringShort（）→String 这个小部件的简短文字描述 Operators运算符 operator ==(dynamic other) → bool 等值运算符。 […]","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter Text","slug":"Flutter-Text","permalink":"https://ifeiyv.github.io/tags/Flutter-Text/"}]},{"title":"Flutter开发之Scaffold Widget","slug":"Flutter开发之Scaffold Widget","date":"2019-08-20T01:51:53.000Z","updated":"2020-03-17T07:17:21.931Z","comments":true,"path":"2019/08/20/Flutter开发之Scaffold Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/20/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BScaffold%20Widget/","excerpt":"","text":"Scaffold 实现基本材料设计视觉布局结构 构造函数(Constructors)123456789101112131415161718Scaffold(&#123; Key key, PreferredSizeWidget appBar, Widget body, Widget floatingActionButton, FloatingActionButtonLocation floatingActionButtonLocation, FloatingActionButtonAnimator floatingActionButtonAnimator, List&lt;Widget&gt; persistentFooterButtons, Widget drawer, Widget endDrawer, Widget bottomNavigationBar, Widget bottomSheet, Color backgroundColor, bool resizeToAvoidBottomPadding, bool resizeToAvoidBottomInset, bool primary: true, DragStartBehavior drawerDragStartBehavior: DragStartBehavior.start, bool extendBody: false &#125;) 属性（Properties） appBar → PreferredSizeWidget 顶部导航栏 backgroundColor → Color 背景色 body → Widget Scaffold的主要内容 bottomNavigationBar → Widget 底部导航栏 bottomSheet → Widget The persistent bottom sheet to display. […] drawer → Widget 显示在容器侧面的面板，通常隐藏在移动设备上。从左到右（TextDirection.ltr）或从右到左（TextDirection.rtl）滑入 drawerDragStartBehavior → DragStartBehavior 确定处理拖动开始行为的方式 endDrawer → Widget 显示在身体侧面的面板，通常隐藏在移动设备上。从右到左（TextDirection.ltr）或从左到右（TextDirection.rtl）滑动 extendBody → bool 如果为true，并且指定了bottomNavigationBar或persistentFooterButtons，则body将延伸到Scaffold的底部，而不是仅延伸到bottomNavigationBar或persistentFooterButtons的顶部 floatingActionButton → Widget 显示在容器上方的按钮，位于右下角 floatingActionButtonAnimator → FloatingActionButtonAnimator Animator将floatingActionButton移动到新的floatingActionButtonLocation floatingActionButtonLocation → FloatingActionButtonLocation 负责确定floatingActionButton的去向 persistentFooterButtons → List 一组显示在脚手架底部的按钮 primary → bool 此脚手架是否显示在屏幕顶部 resizeToAvoidBottomInset → bool 如果为true，则body和scaffold的浮动小部件应自行调整大小，以避免屏幕键盘的高度由环境MediaQuery的MediaQueryData.viewInsets底部属性定义 resizeToAvoidBottomPadding → bool 不推荐使用此标志，请改用resizeToAvoidBottomInset,@Deprecated（’使用resizeToAvoidBottomInset指定键盘出现时是否应调整主体大小’）","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter Scaffold","slug":"Flutter-Scaffold","permalink":"https://ifeiyv.github.io/tags/Flutter-Scaffold/"}]},{"title":"Flutter开发之Row Widget","slug":"Flutter开发之Row Widget","date":"2019-08-18T09:43:24.000Z","updated":"2020-03-17T07:16:25.014Z","comments":true,"path":"2019/08/18/Flutter开发之Row Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/18/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BRow%20Widget/","excerpt":"","text":"Row 一个在水平数组中显示它的子级的小部件 要使子级扩展以填充可用的水平空间, 请将子级包裹在一个展开的小部件中。 想使用竖直布局的，请前往-&gt; Column 如果你只有一个子级, 那就考虑用 “对齐” 或 “中心” 来定位子级。 本示例将可用空间划分为三个 (水平), 并将文本置于前两个单元格中的中心, 并将 Flutter 图标置于第三个单元格的中心: 12345678910111213141516Row( children: &lt;Widget&gt;[ Expanded( child: Text(&#39;Deliver features faster&#39;, textAlign: TextAlign.center), ), Expanded( child: Text(&#39;Craft beautiful UIs&#39;, textAlign: TextAlign.center), ), Expanded( child: FittedBox( fit: BoxFit.contain, &#x2F;&#x2F; otherwise the logo will be tiny child: const FlutterLogo(), ), ), ],) 效果图：","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter Row","slug":"Flutter-Row","permalink":"https://ifeiyv.github.io/tags/Flutter-Row/"}]},{"title":"Flutter开发之RaisedButton Widget","slug":"Flutter开发之RaisedButton Widget","date":"2019-08-17T14:15:14.000Z","updated":"2020-03-17T07:15:29.111Z","comments":true,"path":"2019/08/17/Flutter开发之RaisedButton Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/17/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BRaisedButton%20Widget/","excerpt":"","text":"RaisedButton 一个凸起的按钮 如果onPressed（即为按钮点击事件）回调为null，则该按钮将被禁用，默认情况下将类似于disabledColor中的平面按钮。如果您尝试更改按钮的颜色并且没有任何效果，请检查您是否正在传递非null onPressed处理程序。 如果您想为点击提供墨水飞溅效果,但不想使用按钮,请考虑直接使用inkwell。 凸起按钮的最小尺寸为88.0×36.0，可以用ButtonTheme覆盖。 此示例演示如何呈现禁用的RaisedButton，启用的RaisedButton以及最后一个具有渐变背景的RaisedButton: 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Widget build(BuildContext context) &#123; return Center( child: Column( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ const RaisedButton( onPressed: null, child: Text( &#39;Disabled Button&#39;, style: TextStyle(fontSize: 20) ), ), const SizedBox(height: 30), RaisedButton( onPressed: () &#123;&#125;, child: const Text( &#39;Enabled Button&#39;, style: TextStyle(fontSize: 20) ), ), const SizedBox(height: 30), RaisedButton( onPressed: () &#123;&#125;, textColor: Colors.white, padding: const EdgeInsets.all(0.0), child: Container( decoration: const BoxDecoration( gradient: LinearGradient( colors: &lt;Color&gt;[ Color(0xFF0D47A1), Color(0xFF1976D2), Color(0xFF42A5F5), ], ), ), padding: const EdgeInsets.all(10.0), child: const Text( &#39;Gradient Button&#39;, style: TextStyle(fontSize: 20) ), ), ), ], ), );&#125; 构造函数（Constructors） 创建一个填充按钮 1234567891011121314151617181920RaisedButton(&#123; Key key, @required VoidCallback onPressed, ValueChanged&lt;bool&gt; onHighlightChanged, ButtonTextTheme textTheme, Color textColor, Color disabledTextColor, Color color, Color disabledColor, Color highlightColor, Color splashColor, Brightness colorBrightness, double elevation, double highlightElevation, double disabledElevation, EdgeInsetsGeometry padding, ShapeBorder shape, Clip clipBehavior: Clip.none, MaterialTapTargetSize materialTapTargetSize, Duration animationDuration, Widget child &#125;) 从一对小部件创建一个填充按钮，用作按钮的图标和标签 12345678910111213141516171819202122RaisedButton.icon(&#123; Key key, @required VoidCallback onPressed, ValueChanged&lt;bool&gt; onHighlightChanged, ButtonTextTheme textTheme, Color textColor, Color disabledTextColor, Color color, Color disabledColor, Color highlightColor, Color splashColor, Brightness colorBrightness, double elevation, double highlightElevation, double disabledElevation, ShapeBorder shape, Clip clipBehavior, MaterialTapTargetSize materialTapTargetSize, Duration animationDuration, @required Widget icon, @required Widget label &#125;) 属性（Properties） animationDuration → Duration 动画的持续时间 child → Widget 按钮的标签部件 clipBehavior → Clip 根据此选项，内容将被剪裁（或不剪辑） color → Color 按钮的填充颜色，由其材料显示，同时处于默认（未按下，已启用）状态 colorBrightness → Brightness 用于设置按钮的主题亮度 disabledColor → Color 禁用按钮时按钮的填充颜色 disabledElevation → double 按钮相对于其父级的高度 disabledTextColor → Color 禁用按钮时用于此按钮文本的颜色 elevation → double 放置此按钮相对于其父按钮的Z坐标 enabled → bool 设置启用还是禁用按钮 hashCode → int 此对象的哈希码(只读) height → double 按钮的垂直范围(即高度) highlightColor → Color 按钮的InkWell的高亮颜色 highlightElevation → double 启用并按下按钮时按钮相对于其父级的高度 key → Key 控制一个小部件如何替换树中的另一个小部件 materialTapTargetSize → MaterialTapTargetSize 配置点击目标的最小尺寸 minWidth → double 按钮占据的最小水平范围(最小宽度) onHighlightChanged → ValueChanged&lt;bool&gt; 由底层InkWell小部件的InkWell.onHighlightChanged回调调用 onPressed → VoidCallback 点击或以其他方式激活按钮时调用的回调 padding → EdgeInsetsGeometry buttons子级的内部填充 runtimeType → Type 表示对象的运行时类型(只读) shape → ShapeBorder 按钮的阴影效果设置 splashColor → Color 按钮墨水的泼溅颜色 textColor → Color 按钮的文本颜色 textTheme → ButtonTextTheme 定义按钮的基色，以及按钮的最小尺寸，内部填充和形状的默认值","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter RaisedButton","slug":"Flutter-RaisedButton","permalink":"https://ifeiyv.github.io/tags/Flutter-RaisedButton/"}]},{"title":"Flutter开发之Image Widget","slug":"Flutter开发之Image Widget","date":"2019-08-16T03:16:41.000Z","updated":"2020-03-17T07:14:14.190Z","comments":true,"path":"2019/08/16/Flutter开发之Image Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/16/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BImage%20Widget/","excerpt":"","text":"Image Widget 显示图像的小部件,支持以下图像格式: JPEG、PNG、GIF、动画 GIF、WebP、动画 WebP、BMP 和 WBMP 为图像可以指定的各种方式提供了几个构造函数: new Image, 通过 ImageProvider获取图像 new Image.asset, 使用key值从资源包获取图像 new Image.network, 通过URL网络请求获取图像 new Image.file, 从文件中获取图像. new Image.memory, 从 Uint8List中 获取图像. 构造方法（Constructors） Image 创建一个显示图像的小部件 123456789101112131415Image(&#123; Key key, @required ImageProvider image, String semanticLabel, bool excludeFromSemantics: false, double width, double height, Color color, BlendMode colorBlendMode, BoxFit fit, AlignmentGeometry alignment: Alignment.center, ImageRepeat repeat: ImageRepeat.noRepeat, Rect centerSlice, bool matchTextDirection: false, bool gaplessPlayback: false, FilterQuality filterQuality: FilterQuality.low &#125;) 创建一个小部件,显示从资源包里获得的 ImageStream,图像的键是由名称参数给出的 12345678910111213141516171819Image.asset(String name, &#123; Key key, AssetBundle bundle, String semanticLabel, bool excludeFromSemantics: false, double scale, double width, double height, Color color, BlendMode colorBlendMode, BoxFit fit, AlignmentGeometry alignment: Alignment.center, ImageRepeat repeat: ImageRepeat.noRepeat, Rect centerSlice, bool matchTextDirection: false, bool gaplessPlayback: false, String package, FilterQuality filterQuality: FilterQuality.low &#125;) 创建一个小部件, 显示从文件中获得的 ImageStream 12345678910111213141516Image.file(File file, &#123; Key key, double scale: 1.0, String semanticLabel, bool excludeFromSemantics: false, double width, double height, Color color, BlendMode colorBlendMode, BoxFit fit, AlignmentGeometry alignment: Alignment.center, ImageRepeat repeat: ImageRepeat.noRepeat, Rect centerSlice, bool matchTextDirection: false, bool gaplessPlayback: false, FilterQuality filterQuality: FilterQuality.low &#125;) 创建一个小部件,显示从Uint8List中获得的ImageStream 12345678910111213141516Image.memory(Uint8List bytes, &#123; Key key, double scale: 1.0, String semanticLabel, bool excludeFromSemantics: false, double width, double height, Color color, BlendMode colorBlendMode, BoxFit fit, AlignmentGeometry alignment: Alignment.center, ImageRepeat repeat: ImageRepeat.noRepeat, Rect centerSlice, bool matchTextDirection: false, bool gaplessPlayback: false, FilterQuality filterQuality: FilterQuality.low&#125;) 创建一个小部件, 显示从网络获得的ImageStream 1234567891011121314151617Image.network(String src, &#123; Key key, double scale: 1.0, String semanticLabel, bool excludeFromSemantics: false, double width, double height, Color color, BlendMode colorBlendMode, BoxFit fit, AlignmentGeometry alignment: Alignment.center, ImageRepeat repeat: ImageRepeat.noRepeat, Rect centerSlice, bool matchTextDirection: false, bool gaplessPlayback: false, FilterQuality filterQuality: FilterQuality.low, Map&lt;String, String&gt; headers &#125;) 属性（Properties） alignment → AlignmentGeometry 设置图像的对齐方式 centerSlice → Rect 九片图像的中心切片 中心切片内的图像区域将水平和垂直拉伸，以使图像适合其目标 中心切片上方和下方的图像区域将仅水平拉伸，中心切片左侧和右侧的图像区域将仅垂直拉伸 color → Color 如果非 null, 则使用颜色混合模式将此颜色与每个图像像素混合 colorBlendMode → BlendMode 用于将颜色与此图像相结合 excludeFromSemantics → bool 是否从语义中排除此图像 filterQuality → FilterQuality 用于设置图像的FilterQuality fit → BoxFit 图片填充的方式 contain 在目标框中尽可能大的显示完整图像 cover 在目标框中尽可能小的覆盖整个目标框 fill 通过拉伸纵横比来填充整个目标框 fitHeight 在目标框中高度填充满，不论宽度是否溢出 fitWidth 在目标框中宽度填充满，不论高度是否溢出 none 对齐目标框内的源（默认情况下，居中）并丢弃位于框外的源的任何部分。源图像未调整大小。 scaleDown 对齐目标框中的源 (默认情况下, 居中), 并在必要时缩小源的比例, 以确保源适合框中。 gaplessPlayback → bool 当图像更换时是继续显示旧图像 (true), 还是短暂不显示任何内容 (false) height → double 如果非空, 则要求图像具有此高度 image → ImageProvider 要显示的图像 matchTextDirection → bool 是否将图像绘制到文本方向的方向 repeat → ImageRepeat 如何绘制图像不包括的布局边界的任何部分 noRepeat 让盒子的未覆盖部分保持透明,不重复 repeat 在 x 和 y 方向上重复图像, 直到框被填满 repeatX 按 x 方向重复图像, 直到水平方向填充满 repeatY 按 Y 方向重复图像, 直到垂直方向填充满 semanticLabel → String 对图像的语义描述 width → double 如果非空, 则要求图像具有此宽度 hashCode → int 此对象的哈希代码 key → Key 控制一个小部件如何替换树中的另一个小部件 runtimeType → Type 对象的运行时类型 方法（Methods） 在树中的给定位置为这个小部件创建可变状态。 createState() → _ImageState 添加与节点管理相关联的其他属性 debugFillProperties(DiagnosticPropertiesBuilder properties) → void 创建StatelessElement以管理此窗口小部件在树中的位置 createElement() → StatelessElement 返回描述此节点的子节点的DiagnosticsNode对象列表。 debugDescribeChildren() → List 访问不存在的方法或属性时调用 noSuchMethod(Invocation invocation) → dynamic 返回调试工具和DiagnosticsNode.toStringDeep使用的对象的调试表示形式 toDiagnosticsNode({String name, DiagnosticsTreeStyle style }) → DiagnosticsNode 返回此对象的字符串表示形式 toString({DiagnosticLevel minLevel: DiagnosticLevel.debug }) → String 返回此节点及其后代的字符串表示形式 toStringDeep({String prefixLineOne: ‘’, String prefixOtherLines, DiagnosticLevel minLevel: DiagnosticLevel.debug }) → String 返回对象的单行详细描述 toStringShallow({String joiner: ‘, ‘, DiagnosticLevel minLevel: DiagnosticLevel.debug }) → String 这个小部件的简短文字描述 toStringShort() → String","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter Image","slug":"Flutter-Image","permalink":"https://ifeiyv.github.io/tags/Flutter-Image/"}]},{"title":"Flutter开发之Container Widget","slug":"Flutter开发之Container Widget","date":"2019-08-15T06:22:01.000Z","updated":"2020-03-17T07:13:08.156Z","comments":true,"path":"2019/08/15/Flutter开发之Container Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/15/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BContainer%20Widget/","excerpt":"","text":"Container Widget 一个方便的小部件, 结合了普通的绘画、定位和大小的小部件。 容器首先用填充物（由装饰中存在的任何边界膨胀）包围子对象，然后对填充范围应用附加约束（如果其中一个为非空，则将宽度和高度合并为约束）。然后容器被从边缘描述的额外的空白空间包围。 在绘画过程中，容器首先应用给定的变换，然后绘制装饰填充填充范围，然后绘制子对象，最后绘制前场装饰，也填充填充填充范围。 没有子对象的容器尽量大，除非传入的约束是无限的，在这种情况下，它们尽量小。有子对象的容器会根据子对象的大小来调整大小。构造函数的width、height和constraints参数重写了这一点。 布局行为介绍(Layout behavior) 有关框布局模型的介绍，请参阅BoxConstraints。 由于Container结合了许多其他小部件，每个小部件都有自己的布局行为，因此Container的布局行为有点复杂。 摘要：容器尝试按顺序：遵循对齐，将自身大小调整为子对象，以符合宽度，高度和约束，以扩展以适合父对象，尽可能小。 进一步来说： 如果窗口小部件没有子节点，没有高度，没有宽度，没有约束，并且父节点提供无限制约束，则Container尝试尽可能小。 如果窗口小部件没有子节点且没有对齐，但提供了高度，宽度或约束，则在给定这些约束和父节点约束的组合的情况下，Container会尽可能小。 如果窗口小部件没有子节点，没有高度，没有宽度，没有约束，没有对齐，但是父节点提供了有界约束，那么Container会扩展以适应父节点提供的约束。 如果窗口小部件具有对齐，并且父窗口提供无限制约束，则Container会尝试围绕子窗口调整自身大小。 如果窗口小部件具有对齐，并且父窗口提供有界约束，则Container会尝试展开以适合父窗口，然后根据对齐方式将子项置于其自身内部。 否则，窗口小部件具有子级但没有高度，没有宽度，没有约束，也没有对齐，并且Container将约束从父级传递给子级并调整其大小以匹配子级。 边距和填充属性也会影响布局，如这些属性的文档中所述。 （它们的效果仅仅增加了上述规则。）装饰可以隐含地增加填充（例如，BoxDecoration中的边界有助于填充）;请参阅Decoration.padding。 此示例显示一个48x48琥珀色方块（放置在中心小部件内，以防父小部件对容器应采用的大小有自己的意见），并留有一个空白，使其远离相邻小部件： 12345678Center( child: Container( margin: const EdgeInsets.all(10.0), color: Colors.amber[600], width: 48.0, height: 48.0, ),) 这个例子展示了如何同时使用容器的许多特性。这些约束被设置为适合字体大小加上足够的垂直净空，同时水平展开以适合父级。填充用于确保内容和文本之间有空间。这个颜色使盒子变成蓝色。对齐会使子项在框中居中。最后，变换对整个装置应用轻微的旋转以完成效果: 1234567891011121314Container( constraints: BoxConstraints.expand( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 200.0, ), padding: const EdgeInsets.all(8.0), color: Colors.blue[600], alignment: Alignment.center, child: Text(&#39;Hello World&#39;, style: Theme.of(context) .textTheme .display1 .copyWith(color: Colors.white)), transform: Matrix4.rotationZ(0.1),) 也可以看看： AnimatedContainer，一种在变化时平滑动画属性的变体。边框，其中包含大量使用Container的示例。墨水，在材质上绘制装饰，允许InkResponse和InkWell喷溅在它们上面绘画。布局小部件的目录。 构造方法（Constructors） 创建一个小部件, 结合了普通的绘画、定位和大小调整小部件。 123456789101112Container(&#123;Key key, AlignmentGeometry alignment, EdgeInsetsGeometry padding, Color color, Decoration decoration, Decoration foregroundDecoration, double width, double height, BoxConstraints constraints, EdgeInsetsGeometry margin, Matrix4 transform, Widget child &#125;) 属性（Properties） alignment → AlignmentGeometry 对齐内部的子级 child → Widget 容器内部的子级 constraints → BoxConstraints 要应用于子级的附加约束 decoration → Decoration 子级背后的装饰 可以设置边框、背景色、背景图片、圆角等属性 需要注意的是 deoration和 color 背景颜色不能共存，二者同时只能有一个123456789decoration: new BoxDecoration( border: new Border.all(width: 2.0, color: Colors.red), color: Colors.grey, borderRadius: new BorderRadius.all(new Radius.circular(20.0)), image: new DecorationImage( image: new NetworkImage(&#39;http:&#x2F;&#x2F;b-ssl.duitang.com&#x2F;uploads&#x2F;item&#x2F;201609&#x2F;26&#x2F;20160926203611_HXQxk.jpeg&#39;), centerSlice: new Rect.fromLTRB(270.0, 180.0, 1360.0, 730.0), ), ), ) 第一张图设置了背景色，未使用decoration；第二张图设置了decoration，未设置背景色 foregroundDecoration → Decoration 在子级前面的装饰 可以设置边框、背景色、背景图片、圆角等属性 foregroundDecoration和 color 背景颜色可以共存，但是color有可能被遮挡 会遮挡child margin → EdgeInsetsGeometry 我的理解就是外边距 padding → EdgeInsetsGeometry 我的理解就是内边距 transform → Matrix4 在绘制容器之前要应用的转换矩阵 hashCode → int 此对象的哈希代码 key → Key 控制一个小部件如何替换树中的另一个小部件 runtimeType → Type 对象的运行时类型 方法（Methods） build(BuildContext context) → Widget 描述此窗口小部件表示的用户界面部分 debugFillProperties(DiagnosticPropertiesBuilder properties) → void 添加与节点关联的其他属性 createElement() → StatelessElement 创建StatelessElement以管理此窗口小部件在树中的位置 debugDescribeChildren() → List 返回描述此节点的子节点的DiagnosticsNode对象列表。 noSuchMethod(Invocation invocation) → dynamic 访问不存在的方法或属性时调用 toDiagnosticsNode({String name, DiagnosticsTreeStyle style }) → DiagnosticsNode 返回调试工具和DiagnosticsNode.toStringDeep使用的对象的调试表示形式 toString({DiagnosticLevel minLevel: DiagnosticLevel.debug }) → String 返回此对象的字符串表示形式 toStringDeep({String prefixLineOne: ‘’, String prefixOtherLines, DiagnosticLevel minLevel: DiagnosticLevel.debug }) → String 返回此节点及其后代的字符串表示形式 toStringShallow({String joiner: ‘, ‘, DiagnosticLevel minLevel: DiagnosticLevel.debug }) → String 返回对象的单行详细描述 toStringShort() → String 这个小部件的简短文字描述","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter Container","slug":"Flutter-Container","permalink":"https://ifeiyv.github.io/tags/Flutter-Container/"}]},{"title":"Flutter开发之BottomNavigationBar底部导航栏","slug":"Flutter开发之BottomNavigationBar底部导航栏","date":"2019-08-14T07:11:47.000Z","updated":"2020-03-17T07:13:11.744Z","comments":true,"path":"2019/08/14/Flutter开发之BottomNavigationBar底部导航栏/","link":"","permalink":"https://ifeiyv.github.io/2019/08/14/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BBottomNavigationBar%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F/","excerpt":"","text":"BottomNavigationBar 显示在应用程序的底部，用于在少量视图中进行选择，通常在三到五之间。 底部导航栏通常与Scaffold结合使用，它作为Scaffold.bottomNavigationBar参数提供。 底部导航栏的类型更改其项目的显示方式。如果未指定，则当少于四个项时它会自动设置为BottomNavigationBarType.fixed，否则为BottomNavigationBarType.shifting。 BottomNavigationBarType.fixed，当少于四个项目时的默认值。如果选中的项目为非null，则使用selectedItemColor渲染所选项目，否则使用主题的ThemeData.primaryColor。如果backgroundColor为null，则导航栏的背景颜色默认为Material背景颜色ThemeData.canvasColor（基本上是不透明的白色）。 BottomNavigationBarType.shifting，当有四个或更多项时的默认值。如果selectedItemColor为null，则所有项目都以白色呈现。导航栏的背景颜色与所选项目的BottomNavigationBarItem.backgroundColor相同。在这种情况下，假设每个项目将具有不同的背景颜色，并且背景颜色将与白色形成鲜明对比。 此示例显示BottomNavigationBar，因为它在Scaffold小部件中使用。 BottomNavigationBar有三个BottomNavigationBarItem小部件，currentIndex设置为索引0.所选项目为琥珀色。 _onItemTapped函数更改所选项的索引，并在Scaffold的中心显示相应的消息: 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int _selectedIndex &#x3D; 0;static const TextStyle optionStyle &#x3D; TextStyle(fontSize: 30, fontWeight: FontWeight.bold);static const List&lt;Widget&gt; _widgetOptions &#x3D; &lt;Widget&gt;[ Text( &#39;Index 0: Home&#39;, style: optionStyle, ), Text( &#39;Index 1: Business&#39;, style: optionStyle, ), Text( &#39;Index 2: School&#39;, style: optionStyle, ),];void _onItemTapped(int index) &#123; setState(() &#123; _selectedIndex &#x3D; index; &#125;);&#125;@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: const Text(&#39;BottomNavigationBar Sample&#39;), ), body: Center( child: _widgetOptions.elementAt(_selectedIndex), ), bottomNavigationBar: BottomNavigationBar( items: const &lt;BottomNavigationBarItem&gt;[ BottomNavigationBarItem( icon: Icon(Icons.home), title: Text(&#39;Home&#39;), ), BottomNavigationBarItem( icon: Icon(Icons.business), title: Text(&#39;Business&#39;), ), BottomNavigationBarItem( icon: Icon(Icons.school), title: Text(&#39;School&#39;), ), ], currentIndex: _selectedIndex, selectedItemColor: Colors.amber[800], onTap: _onItemTapped, ), );&#125; 构造方法（Constructors） 创建一个底部导航栏，通常用作Scaffold的Scaffold.bottomNavigationBar参数。 1234567891011121314151617BottomNavigationBar(&#123; Key key, @required List&lt;BottomNavigationBarItem&gt; items, ValueChanged&lt;int&gt; onTap, int currentIndex: 0, double elevation: 8.0, BottomNavigationBarType type, Color fixedColor, Color backgroundColor, double iconSize: 24.0, Color selectedItemColor, Color unselectedItemColor, double selectedFontSize: 14.0, double unselectedFontSize: 12.0, bool showSelectedLabels: true, bool showUnselectedLabels &#125;) 属性（Properties） backgroundColor → Color 背景颜色 currentIndex → int 当前活动BottomNavigationBarItem的项目索引(一般就是当前选中的那个项目索引) elevation → double 此底部导航栏的Z坐标 fixedColor → Color 选中项目颜色的值（只读） iconSize → double 所有BottomNavigationBarItem图标的大小 items → List&lt;BottomNavigationBarItem&gt; 定义在底部导航栏中排列的按钮项的外观 onTap → ValueChanged&lt;int&gt; 点击其中一个项目时响应事件 selectedFontSize → double 选中时BottomNavigationBarItem标签的字体大小 selectedItemColor → Color 选中时BottomNavigationBarItem.icon和BottomNavigationBarItem.label的颜色 showSelectedLabels → bool 是否为未选择的BottomNavigationBarItems显示标签 showUnselectedLabels → bool 是否为选定的BottomNavigationBarItem显示标签 type → BottomNavigationBarType 定义BottomNavigationBar的布局和行为 unselectedFontSize → double 未选中BottomNavigationBarItem标签的字体大小 unselectedItemColor → Color 未选中的BottomNavigationBarItem.icon和BottomNavigationBarItem.labels的颜色 hashCode → int 对象的哈希值（只读） key → Key 控制一个小部件如何替换树中的另一个小部件 runtimeType → Type 表示对象的运行时类型(只读)","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter BottomNavigationBar","slug":"Flutter-BottomNavigationBar","permalink":"https://ifeiyv.github.io/tags/Flutter-BottomNavigationBar/"}]},{"title":"Flutter开发之AppBar Widget","slug":"Flutter开发之AppBar Widget","date":"2019-08-13T06:12:33.000Z","updated":"2020-03-17T07:10:25.573Z","comments":true,"path":"2019/08/13/Flutter开发之AppBar Widget/","link":"","permalink":"https://ifeiyv.github.io/2019/08/13/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BAppBar%20Widget/","excerpt":"","text":"AppBar应用栏通常用于Scaffold.appBar属性，该属性将应用栏放置在屏幕顶部的固定高度小部件中。对于可滚动的应用栏，请参阅SliverAppBar，它将一个AppBar嵌入到一个条子中，以便在CustomScrollView中使用。 AppBar在底部（如果有）上方显示工具栏小部件，前导，标题和操作。底部通常用于TabBar。如果指定了flexibleSpace窗口小部件，则它将堆叠在工具栏和底部窗口小部件后面。下图显示了当编写语言从左到右（例如英语）时，每个插槽在工具栏中的显示位置： 如果省略了前导小部件，但AppBar位于带有抽屉的脚手架中，则会插入一个按钮以打开抽屉。否则，如果最近的导航器具有任何先前的路径，则会插入BackButton。可以通过将automatedImplyLeading设置为false来关闭此行为。在这种情况下，空的前导小部件将导致中间/标题小部件拉伸开始。 构造方法（Constructors）1234567891011121314151617181920AppBar(&#123; Key key, Widget leading, bool automaticallyImplyLeading: true, Widget title, List&lt;Widget&gt; actions, Widget flexibleSpace, PreferredSizeWidget bottom, double elevation, ShapeBorder shape, Color backgroundColor, Brightness brightness, IconThemeData iconTheme, IconThemeData actionsIconTheme, TextTheme textTheme, bool primary: true, bool centerTitle, double titleSpacing: NavigationToolbar.kMiddleSpacing, double toolbarOpacity: 1.0, double bottomOpacity: 1.0 &#125;) eg: 1234567891011121314151617181920AppBar( title: Text(&#39;My Fancy Dress&#39;), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.playlist_play), tooltip: &#39;Air it&#39;, onPressed: _airDress, ), IconButton( icon: Icon(Icons.playlist_add), tooltip: &#39;Restitch it&#39;, onPressed: _restitchDress, ), IconButton( icon: Icon(Icons.playlist_add_check), tooltip: &#39;Repair it&#39;, onPressed: _repairDress, ), ],) 属性（Properties） actions → List 要在标题小部件后显示的小部件 actionsIconTheme → IconThemeData 用于应用栏操作中显示的图标的颜色，不透明度和大小。仅当操作的主题不同于应用栏的主要小部件中显示的图标时，才应使用此选项 automaticallyImplyLeading → bool Controls whether we should try to imply the leading widget if null. […] backgroundColor → Color 用于应用栏材质的颜色。通常这应该与亮度，iconTheme，textTheme一起设置。 bottom → PreferredSizeWidget 此小组件显示在应用栏的底部 bottomOpacity → double 应用栏底部的不透明程度(0.0 - 1.0) brightness → Brightness 应用栏材质的亮度。通常，这与backgroundColor，iconTheme，textTheme一起设置 centerTitle → bool 标题是否居中 elevation → double 放置此应用程序栏相对于其父应用程序栏的Z坐标 flexibleSpace → Widget 此小组件堆叠在工具栏和选项卡栏后面。它的高度与应用栏的整体高度相同 iconTheme → IconThemeData 用于应用栏图标的颜色，不透明度和大小。通常，这与backgroundColor，brightness，textTheme一起设置 leading → Widget 要在标题之前显示的小部件 preferredSize → Size 高度为kToolbarHeight和底部窗口小部件首选高度之和的大小 primary → bool 此应用栏是否显示在屏幕顶部 shape → ShapeBorder 形状和阴影 textTheme → TextTheme 应用栏中用于文本的排版样式。通常，这与亮度backgroundColor，iconTheme一起设置 title → Widget appbar中显示的主要小部件 titleSpacing → double 横轴上标题内容周围的间距。即使没有前导内容或操作，也会应用此间距。如果希望title占用所有可用空间，请将此值设置为0.0 toolbarOpacity → double 应用栏的工具栏部分透明度(0.0-1.0)","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter AppBar","slug":"Flutter-AppBar","permalink":"https://ifeiyv.github.io/tags/Flutter-AppBar/"}]},{"title":"Flutter开发之基础 Widgets","slug":"Flutter开发之基础 Widgets","date":"2019-08-12T01:32:34.000Z","updated":"2020-03-17T07:08:08.594Z","comments":true,"path":"2019/08/12/Flutter开发之基础 Widgets/","link":"","permalink":"https://ifeiyv.github.io/2019/08/12/Flutter%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9F%BA%E7%A1%80%20Widgets/","excerpt":"","text":"基础 Widgets Container 一个拥有绘制、定位、调整大小的 widget。 Row 在水平方向上排列子widget的列表。 Column 在垂直方向上排列子widget的列表。 Image 一个显示图片的widget。 Text 单一格式的文本。 Icon 图标。 RaisedButton Material Design中的button，一个凸起的材质矩形按钮 Scaffold Material Design布局结构的基本实现。此类提供了用于显示drawer、snackbar和底部sheet的API。 AppBar 一个Material Design应用程序栏，由工具栏和其他可能的widget（如TabBar和FlexibleSpaceBar）组成。 FlutterLogo Flutter logo,以widget形式,这个widget遵从IconTheme。 Placeholder 一个绘制了一个盒子的的widget，代表日后有widget将会被添加到该盒子中","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter Widgets","slug":"Flutter-Widgets","permalink":"https://ifeiyv.github.io/tags/Flutter-Widgets/"}]},{"title":"Flutter-go运行报错（FIRAnalyticsConfiguration）","slug":"Flutter-go运行报错（FIRAnalyticsConfiguration）","date":"2019-07-19T13:48:12.000Z","updated":"2020-03-17T07:06:29.106Z","comments":true,"path":"2019/07/19/Flutter-go运行报错（FIRAnalyticsConfiguration）/","link":"","permalink":"https://ifeiyv.github.io/2019/07/19/Flutter-go%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99%EF%BC%88FIRAnalyticsConfiguration%EF%BC%89/","excerpt":"","text":"flutter go 项目下载后，运行报如下错误：flutter run123456789101112131415161718192021Launching lib&#x2F;main.dart on iPhone Xʀ in debug mode...Running Xcode build... Xcode build done. 3.3sFailed to build iOS appError output from Xcode build:↳ ** BUILD FAILED **Xcode&#39;s output:↳ &#x3D;&#x3D;&#x3D; BUILD TARGET firebase_analytics OF PROJECT Pods WITH CONFIGURATION Debug &#x3D;&#x3D;&#x3D; &#x2F;Users&#x2F;l&#x2F;Documents&#x2F;flutter&#x2F;.pub-cache&#x2F;hosted&#x2F;pub.dartlang.org&#x2F;firebase_analytics-2.1.1+2&#x2F;ios&#x2F;Classes&#x2F;FirebaseAnalyticsPlu gin.m:60:7: error: use of undeclared identifier &#39;FIRAnalyticsConfiguration&#39; [[FIRAnalyticsConfiguration sharedInstance] setAnalyticsCollectionEnabled:[enabled boolValue]]; ^ 1 error generated.Could not build the application for the simulator.Error launching application on iPhone Xʀ. 解决方案： 将根目录下pubspec.yaml文件中 firebase_analytics: ^2.0.2+1 改为 firebase_analytics: ^3.0.1 之后运行flutter run 执行通过","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter的坑","slug":"Flutter的坑","permalink":"https://ifeiyv.github.io/tags/Flutter%E7%9A%84%E5%9D%91/"},{"name":"Flutter-go","slug":"Flutter-go","permalink":"https://ifeiyv.github.io/tags/Flutter-go/"}]},{"title":"Flutter Flutter.h file not found","slug":"Flutter Flutter.h file not found","date":"2019-07-05T03:34:54.000Z","updated":"2020-03-17T07:03:29.024Z","comments":true,"path":"2019/07/05/Flutter Flutter.h file not found/","link":"","permalink":"https://ifeiyv.github.io/2019/07/05/Flutter%20Flutter.h%20file%20not%20found/","excerpt":"","text":"1. ‘Flutter/Flutter.h’ file not found解决方案1.点击这里前往下载对应版本文件,替换原来的文件ios/Podfile内容，删除ios/Podfile.lock,重新 pod install 即可 解决方案2.执行代码：flutter run -v 和 flutter doctor -v 检测配置是否成功 可能会出现以下情况： Mac os 10.15 无法打开“idevice_id”,因为无法验证开发者 Mac os 10.15 无法打开“ideviceinfo”,因为无法验证开发者 解决方法 打开终端（Terminal），输入以下命令后回车，如需要，请输入密码 sudo xattr -r -d com.apple.quarantine &lt;path&gt; 注：为应用程序路径，直接从文件夹目录拖拽即可自动填写 解决方案3. 找到 iOS/Flutter 文件夹，再找到以前备份的无报错代码替换掉文件夹内容，应该就不会报错了。 再执行下 flutter build ios --release 编译过程中会重新生成新的 iOS/Flutter 文件夹下内容，覆盖我们替换的文件。 以上解决方案有可能需要结合使用。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter的坑","slug":"Flutter的坑","permalink":"https://ifeiyv.github.io/tags/Flutter%E7%9A%84%E5%9D%91/"}]},{"title":"Flutter 编译成Swift","slug":"Flutter 编译成Swift","date":"2019-06-29T12:14:46.000Z","updated":"2020-03-17T07:06:07.833Z","comments":true,"path":"2019/06/29/Flutter 编译成Swift/","link":"","permalink":"https://ifeiyv.github.io/2019/06/29/Flutter%20%E7%BC%96%E8%AF%91%E6%88%90Swift/","excerpt":"","text":"flutter create -i swift -a kotlin swiftflutterflutter create --org com.yourcompany -i swift -a kotlin --description &#39;Your App Description&#39; your_app_nameflutter run -d 06157df6f3881f3e –flavor tencent","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter命令","slug":"Flutter命令","permalink":"https://ifeiyv.github.io/tags/Flutter%E5%91%BD%E4%BB%A4/"}]},{"title":"Flutter  VSCode命令收集","slug":"Flutter  VSCode命令收集","date":"2019-06-27T02:22:43.000Z","updated":"2020-03-17T06:58:12.854Z","comments":true,"path":"2019/06/27/Flutter  VSCode命令收集/","link":"","permalink":"https://ifeiyv.github.io/2019/06/27/Flutter%20%20VSCode%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/","excerpt":"","text":"open -a Simulator 打开模拟器 flutter run 编译执行flutter程序 flutter packages get 获取相同版本的软件包 flutter packages upgrade 如果要升级到软件包的新版本，例如使用该软件包中的新功能","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/tags/Flutter/"},{"name":"VSCode","slug":"VSCode","permalink":"https://ifeiyv.github.io/tags/VSCode/"}]},{"title":"androidx","slug":"androidx","date":"2019-06-25T08:33:55.000Z","updated":"2020-03-17T06:56:54.624Z","comments":true,"path":"2019/06/25/androidx/","link":"","permalink":"https://ifeiyv.github.io/2019/06/25/androidx/","excerpt":"","text":"1. ViewModelProviders在build.gradle 的 dependencies 中加入 1implementation &#39;androidx.lifecycle:lifecycle-extensions:2.0.0&#39; 在使用的地方导入： 1import androidx.lifecycle.ViewModelProviders; 即可使用： 1myViewModel &#x3D; ViewModelProviders.of(this).get(MyViewModel.class); 该方法 2.1.0 已弃用 ViewModelProviders.of() ,改为 12345&#x2F;&#x2F;导入 import androidx.lifecycle.ViewModelProvider;myViewModel &#x3D; ViewModelProvider(this).get(MyViewModel.class);&#x2F;&#x2F;或者myViewModel &#x3D; ViewModelProvider(getActivity()).get(MyViewModel.class); 2. DataBinding在 build.gradle 的 defaultConfig中加入 123dataBinding&#123; enabled true&#125; Sync Now一下，把下面代码套在布局最外层，即可使用。 1234567891011121314&lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;&gt; &lt;data&gt; &lt;&#x2F;data&gt; &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;这里写自己的布局 &lt;&#x2F;layout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/tags/Android/"}]},{"title":"Android Studio运行Flutter项目run不起来","slug":"Android Studio运行Flutter项目run不起来","date":"2019-06-19T06:46:56.000Z","updated":"2020-03-17T06:55:39.341Z","comments":true,"path":"2019/06/19/Android Studio运行Flutter项目run不起来/","link":"","permalink":"https://ifeiyv.github.io/2019/06/19/Android%20Studio%E8%BF%90%E8%A1%8CFlutter%E9%A1%B9%E7%9B%AErun%E4%B8%8D%E8%B5%B7%E6%9D%A5/","excerpt":"","text":"解决方案： 修改Flutter SDK中的flutter.gradle文件,通过 flutter&gt;packages&gt;flutter_tools&gt;gradle&gt;flutter.gradle(注意这是Flutter SDK安装位置不是Android Studio的)路径找到flutter.gradle，打开flutter.gradle文件，修改配置： 注释掉google()和jcenter(),加入阿里的配置项 maven {url &apos;https://maven.aliyun.com/repository/google&apos;} maven {url &apos;https://maven.aliyun.com/repository/jcenter&apos;} maven {url &apos;https://maven.aliyun.com/nexus/content/groups/public&apos;} 修改后： buildscript { repositories { //注释掉 google()和jcenter() // google() // jcenter() maven {url &apos;https://maven.aliyun.com/repository/google&apos;} maven {url &apos;https://maven.aliyun.com/repository/jcenter&apos;} maven {url &apos;https://maven.aliyun.com/nexus/content/groups/public&apos;} } dependencies { classpath &apos;com.android.tools.build:gradle:3.2.1&apos; } } 手动下载gradle进行配置 找到创建的flutter项目： 通过路径flutterdemo001/android/gradle/wrapper/gradle-wrapper.properties找到对应文件打开后： #Fri Jun 23 08:50:38 CEST 2017 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists distributionUrl=https\\://services.gradle.org/distributions/gradle-4.10.2-all.zip 找到distributionUrl对应的地址https://services.gradle.org/distributions/gradle-4.10.2-all.zip就是gradle的下载地址,注意文件中https后面有个\\,复制到浏览器记得要删掉 点击下载 gradle-4.10.2-all.zip 点击下载其他版本gradle 下载完成后，进行解压。 然后打开目录：Macintosh HD 》 用户 》当前登录用户名称》.gradle》wrapper》dists⁩, 可能有些电脑未打开隐藏文件可见，是看不到.gradle文件夹的,它是一个隐藏文件夹。 使用快捷键shift+command+.来切换隐藏文件可见还是隐藏。找到dists文件夹后，把解压后的gradle拷贝一份放到dists文件夹下即可。","categories":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/categories/Android/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://ifeiyv.github.io/tags/Flutter/"},{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/tags/Android/"}]},{"title":"touch取消textfield的第一响应","slug":"touch取消textfield的第一响应","date":"2019-06-17T05:07:29.000Z","updated":"2020-03-17T07:36:41.718Z","comments":true,"path":"2019/06/17/touch取消textfield的第一响应/","link":"","permalink":"https://ifeiyv.github.io/2019/06/17/touch%E5%8F%96%E6%B6%88textfield%E7%9A%84%E7%AC%AC%E4%B8%80%E5%93%8D%E5%BA%94/","excerpt":"","text":"12345678910111213141516override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; for touch:AnyObject in touches &#123; let t:UITouch &#x3D; touch as! UITouch &#x2F;&#x2F;检测当前触摸的view是否是textField if t.view &#x3D;&#x3D; pwdField || t.view &#x3D;&#x3D; pwdField || t.view &#x3D;&#x3D; phoneField&#123; t.view?.becomeFirstResponder() &#125;else&#123; phoneField.resignFirstResponder() pwdField.resignFirstResponder() verificationField.resignFirstResponder() self.resignFirstResponder() &#125; &#125; &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"Responsder","slug":"Responsder","permalink":"https://ifeiyv.github.io/tags/Responsder/"},{"name":"touch","slug":"touch","permalink":"https://ifeiyv.github.io/tags/touch/"}]},{"title":"Swift Responsder","slug":"SwiftResponsder","date":"2019-06-17T04:57:24.000Z","updated":"2020-03-17T07:35:19.880Z","comments":true,"path":"2019/06/17/SwiftResponsder/","link":"","permalink":"https://ifeiyv.github.io/2019/06/17/SwiftResponsder/","excerpt":"","text":"通过响应者链获取对应的第一个符合条件的Responsder 传入响应检测的起点Responsder，一般用于UIView中查找响应者链中的控制器 1234567func nextResponder(currentView:UIView)-&gt;UIViewController&#123;var vc:UIResponder &#x3D; currentViewwhile vc.isKind(of: UIViewController.self) !&#x3D; true &#123;vc &#x3D; vc.next!&#125;return vc as! UIViewController&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"Responsder","slug":"Responsder","permalink":"https://ifeiyv.github.io/tags/Responsder/"}]},{"title":"Swift中String转类名Class","slug":"Swift中String转类名Class","date":"2019-06-17T03:24:32.000Z","updated":"2020-03-17T07:34:06.790Z","comments":true,"path":"2019/06/17/Swift中String转类名Class/","link":"","permalink":"https://ifeiyv.github.io/2019/06/17/Swift%E4%B8%ADString%E8%BD%AC%E7%B1%BB%E5%90%8DClass/","excerpt":"String-&gt;Class Swift中引入了命名空间的概念，转Class需要拼接命名空间 123456789101112131415161718&#x2F;&#x2F;这是一个简单的通过字符串类名，转Class然后初始化后跳转的一个小例子@objc func OnClick()&#123; &#x2F;&#x2F;控制器字符串名称 let vcNameString &#x3D; &quot;OneViewController&quot; &#x2F;&#x2F;获取命名空间也就是项目名称 let clsName &#x3D; Bundle.main.infoDictionary![&quot;CFBundleExecutable&quot;] as? String &#x2F;&#x2F;拼接 let className&#x3D;clsName! + &quot;.&quot; + vcNameString &#x2F;&#x2F;字符串转Class 需要注意的是这里的&#96;UIViewController&#96;强转必须带上&#96;.Type&#96;,否则转换不成功 let classT &#x3D; NSClassFromString(className)! as! UIViewController.Type URLRouter.shared.pushViewController(viewController:classT.init() , animated: true)&#125;&#x2F;&#x2F;成功完成跳转","text":"String-&gt;Class Swift中引入了命名空间的概念，转Class需要拼接命名空间 123456789101112131415161718&#x2F;&#x2F;这是一个简单的通过字符串类名，转Class然后初始化后跳转的一个小例子@objc func OnClick()&#123; &#x2F;&#x2F;控制器字符串名称 let vcNameString &#x3D; &quot;OneViewController&quot; &#x2F;&#x2F;获取命名空间也就是项目名称 let clsName &#x3D; Bundle.main.infoDictionary![&quot;CFBundleExecutable&quot;] as? String &#x2F;&#x2F;拼接 let className&#x3D;clsName! + &quot;.&quot; + vcNameString &#x2F;&#x2F;字符串转Class 需要注意的是这里的&#96;UIViewController&#96;强转必须带上&#96;.Type&#96;,否则转换不成功 let classT &#x3D; NSClassFromString(className)! as! UIViewController.Type URLRouter.shared.pushViewController(viewController:classT.init() , animated: true)&#125;&#x2F;&#x2F;成功完成跳转 注意 Swift中引入了命名空间的概念，转Class需要拼接命名空间 这里的UIViewController强转必须带上.Type,否则转换不成功","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/tags/Swift/"},{"name":"Class","slug":"Class","permalink":"https://ifeiyv.github.io/tags/Class/"}]},{"title":"Android报错","slug":"Android 报错","date":"2019-06-17T02:30:22.000Z","updated":"2020-03-17T06:53:29.723Z","comments":true,"path":"2019/06/17/Android 报错/","link":"","permalink":"https://ifeiyv.github.io/2019/06/17/Android%20%E6%8A%A5%E9%94%99/","excerpt":"","text":"1.*MISSING ACCESSIBILITY LABEL: WHERE MINSDK &lt; 17, YOU SHOULD PROVIDE AN ‘ANDROID:HINT’ * 在布局文件（默认为main_activity.xml）添加 xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:ignore=&quot;LabelFor&quot;","categories":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/tags/Android/"},{"name":"android","slug":"android","permalink":"https://ifeiyv.github.io/tags/android/"}]},{"title":"根目录下的build.gradle","slug":"『build.gradle』","date":"2019-06-16T04:11:32.000Z","updated":"2020-03-17T06:52:23.106Z","comments":true,"path":"2019/06/16/『build.gradle』/","link":"","permalink":"https://ifeiyv.github.io/2019/06/16/%E3%80%8Ebuild.gradle%E3%80%8F/","excerpt":"","text":"根目录下的build.gradle123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules.buildscript &#123; repositories &#123; google() &#x2F;&#x2F;代码托管库，设置后可以在项目中引用jcenter上的开源项目 jcenter() &#125; &#x2F;&#x2F;引用anroid插件 dependencies &#123; &#x2F;&#x2F;声明gradle插件，插件版本号 classpath &#39;com.android.tools.build:gradle:3.5.3&#39; &#x2F;&#x2F; NOTE: Do not place your application dependencies here; they belong &#x2F;&#x2F; in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; app目录下的build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266&#x2F;&#x2F;声明是Android应用程序还是库模块&#x2F;&#x2F;com.android.appliccation 标识应用程序，可以直接运行&#x2F;&#x2F;com.android.library 标识这是一个库模块，依附于别的应用程序运行apply plugin: &#39;com.android.application&#39;&#x2F;&#x2F;配置项目构建的各种属性android &#123; &#x2F;&#x2F;程序在编译时会检查lint，有任何错误提示会停止build，我们可以关闭这个开关 lintOptions&#123; &#x2F;&#x2F;即使报错也不会停止打包 abortOnError false &#x2F;&#x2F;打包release版本的时候是否进行检测 checkReleaseBuilds false &#125; &#x2F;&#x2F;编译SDK的版本，也就是API Level compileSdkVersion 28 &#x2F;&#x2F;build tools的版本，其中包括了打包工具aapt 、 dx &#x2F;&#x2F;这个目录工具位于 sdk目录&#x2F;build-tools&#x2F; 下 buildToolsVersion &#39;28.0.3&#39; &#x2F;&#x2F;关闭Android Studio的PNG合法性检查 aaptOptions.cruncherEnabled &#x3D; false aaptOptions.useNewCruncher &#x3D; false &#x2F;&#x2F;默认配置 defaultConfig &#123; &#x2F;&#x2F;应用程序的包名 applicationId &quot;com.ifeiyv.android001&quot; &#x2F;&#x2F;最小的SDK版本，如果设置小于这个版本，或者大于maxSdkVersion将无法安装这个应用 minSdkVersion 19 &#x2F;&#x2F;目标sdk版本，充分测试过的版本（建议版本） targetSdkVersion 28 &#x2F;&#x2F;版本号 每次更新增减 versionCode 1 &#x2F;&#x2F;版本号，用户看到的版本号 versionName &quot;1.0&quot; &#x2F;&#x2F;指定打包成Jar文件时候的文件名称 archivesBaseName &#x3D; &quot;demo-$versionName&quot; &#x2F;&#x2F;Native Development Kit &#x2F;&#x2F;原生开发工具包是一组可以让您在Android应用中利用C和c++代码的工具,可用以从您自己的源代码构建,或者利用现有的预构建库. ndk&#123; &#x2F;&#x2F;设置（so）文件名称 moduleName &quot;testfeiyv&quot; ldLibs &quot;log&quot;,&quot;z&quot;,&quot;m&quot;,&quot;jnigraphics&quot;,&quot;android&quot; &#x2F;&#x2F;显示指定支持的ABIs abiFilters &quot;armeabi&quot;,&quot;x86&quot;,&quot;armeabi-v7a&quot; &#x2F;&#x2F;C++11 cFlags &quot;-sd&#x3D;c++11 -fexceptions&quot; stl &quot;gnustl_static&quot; &#125; &#x2F;&#x2F;当方法数超过65535的时候允许打包成多个dex文件，动态加载dex &#x2F;&#x2F;(方法的索引使用的是一个short值，而short最大值是65535) multiDexEnabled true &#x2F;&#x2F;Instrumentation单元测试 testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; sourceSets&#123; main&#123; &#x2F;&#x2F;指定清单文件 manifest.srcFile &#39;AndroidManifest.xml&#39; &#x2F;&#x2F;指定res资源目录 res.srcDirs &#x3D; [&#39;res&#39;] &#x2F;&#x2F;asset资源文件 assets.srcDir &#x3D; [&#39;assets&#39;] &#x2F;&#x2F;jni代码目录 jni.srcDirs &#39;src&#x2F;main&#x2F;jni&#39; &#x2F;&#x2F;jni库目录 jniLibs.srcDir &#39;src&#x2F;main&#x2F;jniLibs&#39; &#x2F;&#x2F;指定Java源代码目录 java.srcDirs &#x3D; [&#39;src&#39;] &#x2F;&#x2F;指定resource目录 resources.srcDirs &#x3D; [&#39;src&#39;] &#x2F;&#x2F;指定aidl目录 aidl.srcDirs &#x3D; [&#39;src&#39;] &#x2F;&#x2F;指定source目录 renderscript.srcDirs &#x3D; [&#39;src&#39;] &#125; &#x2F;&#x2F;指定debug模式的路径 debug.setRoot(&#39;build-types&#x2F;debug&#39;) &#x2F;&#x2F;指定release模式的路径 release.setRoot(&#39;build-types&#x2F;release&#39;) &#125; &#x2F;&#x2F;mltiDex的一些相关配置，这样配置可以使编译速度更快 dexOptions&#123; &#x2F;&#x2F;让它不要对Lib做preDexing preDexLibraries &#x3D; fasle &#x2F;&#x2F;开启incremental dexing,优化编译效率。这个功能Android Studio默认是关闭的 incremental true &#x2F;&#x2F;增加java堆内存大小 javaMaxHeapSize &quot;4g&quot; &#125; &#x2F;&#x2F;签名配置 signingConfigs&#123; release&#123; &#x2F;&#x2F;密钥文件路径 storeFile file(&quot;feiyv.keystore&quot;) &#x2F;&#x2F;密钥文件密码 storePassword &quot;feiyvpwd&quot; &#x2F;&#x2F;key 别名 keyAlias &quot;fy&quot; &#x2F;&#x2F;key密码 keyPassword &quot;fypwd&quot; &#125; debug&#123; &#x2F;&#x2F;密钥文件路径 storeFile file(&quot;feiyv.keystore&quot;) &#x2F;&#x2F;密钥文件密码 storePassword &quot;feiyvpwd&quot; &#x2F;&#x2F;key 别名 keyAlias &quot;fy&quot; &#x2F;&#x2F;key密码 keyPassword &quot;fypwd&quot; &#125; &#125; &#x2F;&#x2F;指定生成安装文件的配置，常有两个子包：release，debug，注：直接运行的都是debug安装文件 buildTypes &#123; &#x2F;&#x2F;release版本的配置，即生成发布版文件的配置 release &#123; &#x2F;&#x2F;是否支持zip zipAlignEnabled true &#x2F;&#x2F;移除无用的resource文件 shrinkResources true &#x2F;&#x2F;是否对代码进行混淆，true标识混淆 minifyEnabled false &#x2F;&#x2F;指定混淆时使用的规则文件： &#x2F;&#x2F;proguard-android.tex指所有项目通用的混淆规则，proguard-rules.pro当前项目特有的混淆规则 &#x2F;&#x2F;release的Proguard默认为Module下的proguard-rules.pro文件 proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39; &#x2F;&#x2F;是否支持调试 debuggable false &#x2F;&#x2F;ndk的一些配置 ndk &#123; &#x2F;&#x2F; cFlags &quot;-std&#x3D;c++11 -fexceptions -O3 -D__RELEASE__&quot; &#x2F;&#x2F; C++11 &#x2F;&#x2F; platformVersion &#x3D; &quot;19&quot; moduleName &quot;hebbewifisafe&quot; &#x2F;&#x2F; 设置库(so)文件名称 ldLibs &quot;log&quot;, &quot;z&quot;, &quot;m&quot;, &quot;jnigraphics&quot;, &quot;android&quot; &#x2F;&#x2F; 引入库，比如要用到的__android_log_print abiFilters &quot;armeabi&quot;, &quot;x86&quot;, &quot;armeabi-v7a&quot;&#x2F;&#x2F; &quot;x86&quot; cFlags &quot;-std&#x3D;c++11 -fexceptions&quot; &#x2F;&#x2F; C++11 stl &quot;gnustl_static&quot; &#125; &#x2F;&#x2F; 采用动态替换字符串的方式生成不同的 release.apk （3.0之后版本的修改方式） applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; output -&gt; if (!variant.buildType.isDebuggable()) &#123; &#x2F;&#x2F; 获取签名的名字 variant.signingConfig.name &#x2F;&#x2F; 要被替换的源字符串 def sourceFile &#x3D; &quot;app-release&quot;; &#x2F;&#x2F; 替换的字符串 def replaceFile &#x3D; &quot;Demo-V$&#123;variant.versionName&#125;.$&#123;releaseTime()&#125;&quot; outputFileName &#x3D; output.outputFile.name.replace(sourceFile, replaceFile) &#125; &#125; &#125; jniDebuggable false &#x2F;&#x2F; 关闭jni调试 &#125; debug &#123; &#x2F;&#x2F; debug版本的配置 minifyEnabled false zipAlignEnabled true shrinkResources true &#x2F;&#x2F; 移除无用的resource文件 proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; debuggable true &#x2F;&#x2F; jniDebuggable true ndk &#123; cFlags &quot;-std&#x3D;c++11 -fexceptions -g -D __DEBUG__&quot; &#x2F;&#x2F; C++11 &#125; jniDebuggable true &#125; &#125; productFlavors&#123; &#x2F;&#x2F;这里可以设置产品发布的一些东西 &#x2F;&#x2F;比如一种软件要发布到不同的渠道 &#x2F;&#x2F;且不同渠道中的包名不同，可以在此处 &#x2F;&#x2F;甚至可以设置不同的AndroidManifest.xml tencent&#123; &#125; huanwei&#123; &#125; all&#123; &#125; &#125; &#x2F;&#x2F; 所谓ProductFlavors其实就是可定义的产品特性， &#x2F;&#x2F; 配合 manifest merger 使用的时候就可以达成在一次编译 &#x2F;&#x2F; 过程中产生多个具有自己特性配置的版本。 &#x2F;&#x2F; 这个配置的作用就是，为每个渠道包产生不同的 UMENG_CHANNEL_VALUE 的值。 productFlavors.all&#123; flavor -&gt; flavor.manifestPlaceholder &#x3D; [UMENG_CHANNEL_VALUE:name] &#125; &#x2F;&#x2F; 指定当前项目的所有依赖关系：本地依赖、库依赖、远程依赖 &#x2F;&#x2F; 本地依赖：可以对本地 Jar 包或目录添加依赖关系 &#x2F;&#x2F; 库依赖：可以对项目中的库模块添加依赖关系 &#x2F;&#x2F; 远程依赖：可以对 jcenter 库上的开源项目添加依赖 &#x2F;&#x2F; 标准的远程依赖格式是 域名:组织名:版本号 dependencies &#123; implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) implementation &#39;com.android.support:recyclerview-v7:28.0.0&#39;&#x2F;&#x2F; implementation &#39;androidx.appcompat:appcompat:1.0.2&#39;&#x2F;&#x2F; implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39; testImplementation &#39;junit:junit:4.12&#39;&#x2F;&#x2F; androidTestImplementation &#39;androidx.test.ext:junit:1.1.0&#39;&#x2F;&#x2F; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.1.1&#39;&#125; &#x2F;&#x2F; 声明是要使用谷歌服务框架 apply plugin: &#39;com.google.gms.google-services&#39; &#x2F;&#x2F; 第三方依赖库的本地缓存路径 task showMeCache &lt;&lt; &#123; configurations.compile.each &#123; println it &#125; &#125; &#x2F;&#x2F; 使用maven仓库。android有两个标准的library文件服务器，一个jcenter一个maven。两者毫无关系。&#x2F;&#x2F; jcenter有的maven可能没有，反之亦然。&#x2F;&#x2F; 如果要使用jcenter的话就把mavenCentral()替换成jcenter()repositories &#123; mavenCentral()&#125; def releaseTime() &#123; return new Date().format(&quot;MMdd.HHmm&quot;)&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ifeiyv.github.io/tags/Android/"},{"name":"android","slug":"android","permalink":"https://ifeiyv.github.io/tags/android/"},{"name":"flutter","slug":"flutter","permalink":"https://ifeiyv.github.io/tags/flutter/"}]},{"title":"SWIFT 常用方法","slug":"SWIFT 常用方法","date":"2019-06-12T02:22:51.000Z","updated":"2020-03-17T07:29:17.101Z","comments":true,"path":"2019/06/12/SWIFT 常用方法/","link":"","permalink":"https://ifeiyv.github.io/2019/06/12/SWIFT%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445&#x2F;&#x2F;&#x2F;&#x2F; LayoutProperties.swift&#x2F;&#x2F; IfeiyvSwift&#x2F;&#x2F;&#x2F;&#x2F; Created by l on 2019&#x2F;6&#x2F;12.&#x2F;&#x2F; Copyright © 2019 ifeiyv. All rights reserved.&#x2F;&#x2F;import UIKitimport CommonCrypto&#x2F;&#x2F;Mark:------------Layoutstruct Screen&#123; &#x2F;&#x2F;MARK:屏幕宽度 static var width:CGFloat&#123; return UIScreen.main.bounds.width &#125; &#x2F;&#x2F;MARK:屏幕高度 static var height:CGFloat&#123; return UIScreen.main.bounds.height &#125; &#x2F;&#x2F;MARK:分辨率 倍率 static var scale:CGFloat&#123; return Screen.width&#x2F;375.0 &#125;&#125;extension UIView&#123; &#x2F;&#x2F;MARK: 设置或者获取UIView的frame var fy_frame:CGRect&#123; set&#123; self.frame &#x3D; fy_frame &#125; get&#123; return self.frame &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的origin var fy_origin:CGPoint&#123; set&#123; self.frame &#x3D; CGRect(x: fy_origin.x, y: fy_origin.y, width: self.fy_width, height: self.fy_height) &#125; get&#123; return self.frame.origin &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的size var fy_size:CGSize&#123; set&#123; self.frame &#x3D; CGRect(x: self.fy_origin.x, y: self.fy_origin.y, width: fy_size.width, height: fy_size.height) &#125; get&#123; return self.frame.size &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的宽度 var fy_width:CGFloat&#123; set&#123; self.frame &#x3D; CGRect(x: self.frame.origin.x, y: self.frame.origin.y, width: fy_width, height: self.frame.size.height) &#125; get&#123; return self.bounds.size.width &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的宽度 var fy_height:CGFloat&#123; set&#123; self.frame &#x3D; CGRect(x: self.frame.origin.x, y: self.frame.origin.y, width: self.frame.size.width, height: fy_height) &#125; get&#123; return self.bounds.size.height &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的x坐标 var fy_x:CGFloat&#123; set&#123; self.frame &#x3D; CGRect(x: fy_x, y: self.frame.origin.y, width: self.frame.size.width, height: self.frame.size.height) &#125; get&#123; return self.frame.origin.x &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的y坐标 var fy_y:CGFloat&#123; set&#123; self.frame &#x3D; CGRect(x: self.frame.origin.x, y: fy_y, width: self.frame.size.width, height:self.frame.size.height) &#125; get&#123; return self.frame.origin.y &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的maxX坐标 var fy_maxX:CGFloat&#123; get&#123; return self.fy_x+self.fy_width &#125; &#125; &#x2F;&#x2F;MARK: 设置或者获取UIView的maxY坐标 var fy_maxY:CGFloat&#123; get&#123; return self.fy_y+self.fy_height &#125; &#125; &#125;extension UIView&#123; &#x2F;&#x2F;MARK: 切圆角 func corner(byRoundingCorners corners: UIRectCorner, radii: CGFloat) &#123; let maskPath &#x3D; UIBezierPath(roundedRect: self.bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radii, height: radii)) let maskLayer &#x3D; CAShapeLayer() maskLayer.frame &#x3D; self.bounds maskLayer.path &#x3D; maskPath.cgPath self.layer.mask &#x3D; maskLayer &#125;&#125;enum FYError: Swift.Error &#123; case NOFINT&#125;extension UINib&#123; &#x2F;&#x2F;MARK: 加载XIB public class func readNibView(str: String) throws -&gt; UIView &#123; let nib &#x3D; UINib.init(nibName: str, bundle: nil) if let view &#x3D; nib.instantiate(withOwner: nil, options: nil).first as? UIView &#123; return view &#125; throw FYError.NOFINT &#125;&#125;&#x2F;&#x2F;Mark:------------UIColorextension UIColor&#123; func fy_RGB(red:CGFloat,green:CGFloat,blue:CGFloat) -&gt; UIColor &#123; return fy_RGBA(red: red, green: green, blue: blue, alpha: 1.0) &#125; func fy_RGBA(red:CGFloat,green:CGFloat,blue:CGFloat,alpha:CGFloat) -&gt; UIColor &#123; return UIColor.init(red: red&#x2F;255.0, green: green&#x2F;255.0, blue: blue&#x2F;255.0, alpha: alpha) &#125; func fy_hexColor(hexColor:String,defaultStringColor:String &#x3D; &quot;000000&quot;,alpha:CGFloat &#x3D; 1.0) -&gt; UIColor &#123; var cString: String &#x3D; hexColor.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) if cString.count &lt; 6 &#123; cString &#x3D; defaultStringColor &#125; if cString.hasPrefix(&quot;0X&quot;) || cString.hasPrefix(&quot;0x&quot;) &#123; cString &#x3D; String(cString.suffix(from: cString.index(cString.startIndex, offsetBy: 2))) &#125; if cString.hasPrefix(&quot;#&quot;) &#123; cString &#x3D; String(cString.suffix(from: cString.index(cString.startIndex, offsetBy: 1))) &#125; if cString.count !&#x3D; 6 &#123; cString &#x3D; defaultStringColor &#125; var range: NSRange &#x3D; NSMakeRange(0, 2) let rString &#x3D; (cString as NSString).substring(with: range) range.location &#x3D; 2 let gString &#x3D; (cString as NSString).substring(with: range) range.location &#x3D; 4 let bString &#x3D; (cString as NSString).substring(with: range) var r: UInt32 &#x3D; 0x0 var g: UInt32 &#x3D; 0x0 var b: UInt32 &#x3D; 0x0 Scanner(string: rString).scanHexInt32(&amp;r) Scanner(string: gString).scanHexInt32(&amp;g) Scanner(string: bString).scanHexInt32(&amp;b) return fy_RGBA(red: CGFloat(r), green: CGFloat(g), blue: CGFloat(b), alpha: alpha) &#125; &#125;&#x2F;&#x2F;Mark:------------Stringextension String&#123; static let EMPTY &#x3D; &quot;&quot; &#x2F;&#x2F;&#x2F; String使用下标截取字符串 &#x2F;&#x2F;&#x2F; 例: &quot;示例字符串&quot;[0..&lt;2] 结果是 &quot;示例&quot; subscript (r: Range&lt;Int&gt;) -&gt; String &#123; get &#123; let startIndex &#x3D; self.index(self.startIndex, offsetBy: r.lowerBound) let endIndex &#x3D; self.index(self.startIndex, offsetBy: r.upperBound) return String(self[startIndex..&lt;endIndex]) &#125; &#125; &#x2F;&#x2F;MARK: 返回一个字符串的前n位, 若字符串长不足n，则直接返回当前字符串 func fy_start(length n: Int) -&gt; String &#123; if self.count &lt; n &#123; return self &#125; if n &lt; 0 &#123; return self &#125; let index &#x3D; self.index(self.startIndex, offsetBy: n) return String(self[..&lt;index]) &#125; &#x2F;&#x2F;MARK: 返回一个字符串的后n位, 若字符串长不足n，则直接返回当前字符串 func fy_last(length n: Int) -&gt; String &#123; if self.count &lt; n &#123; return self &#125; let index &#x3D; self.index((self.endIndex), offsetBy: -n) return String(self[index...]) &#125; &#x2F;&#x2F;MARK: 删除所有的空格 func fy_trimAll() -&gt; String &#123; return self.replacingOccurrences(of: &quot; &quot;, with: String.EMPTY) &#125; &#x2F;&#x2F;MARK: 判断是否包含数字和字母 func fy_isPassWord() -&gt; Bool &#123; let numberRegex:NSPredicate &#x3D; NSPredicate(format: &quot;SELF MATCHES %@&quot;, &quot;^.*[0-9]+.*$&quot;) let letterRegex:NSPredicate &#x3D; NSPredicate(format: &quot;SELF MATCHES %@&quot;, &quot;^.*[A-Za-z]+.*$&quot;) if numberRegex.evaluate(with: self) &amp;&amp; letterRegex.evaluate(with: self)&#123; return true &#125; return false &#125; &#x2F;&#x2F;MARK: md5加密 var fy_md5: String &#123; let cStr &#x3D; self.cString(using: .utf8) let digestLen &#x3D; Int(CC_MD5_DIGEST_LENGTH) let buffer &#x3D; UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: digestLen) CC_MD5(cStr!,(CC_LONG)(strlen(cStr!)), buffer) let md5String &#x3D; NSMutableString() for i in 0 ..&lt; digestLen &#123; md5String.appendFormat(&quot;%02X&quot;, buffer[i]) &#125; free(buffer) return md5String as String &#125; &#x2F;&#x2F;MARK: base64编码 var fy_base64Encoding: String &#123; let data &#x3D; self.data(using: String.Encoding.utf8) var base64String &#x3D; data?.base64EncodedString(options: .lineLength76Characters) base64String &#x3D; base64String?.replacingOccurrences(of: &quot;\\r&quot;, with: &quot;&quot;) return base64String ?? &quot;&quot; &#125; &#x2F;&#x2F;MARK: base64解码 var fy_base64Decoded: String &#123; let decodedData &#x3D; Data(base64Encoded: self, options: Data.Base64DecodingOptions(rawValue: 0)) return String(data: decodedData!, encoding: String.Encoding.utf8) ?? &quot;&quot; &#125; &#x2F;&#x2F;MARK: 返回188****8888类型字符串 func fy_getSecretMobileNo() -&gt; String &#123; if self.isEmpty &#123; return self &#125; if self.count &gt; 7 &#123; return &quot;\\(self.fy_start(length: 3))****\\(self.fy_last(length:4))&quot; &#125;else&#123; return self; &#125; &#125; &#x2F;&#x2F;MARK: 截取从start开始,长度为lenght的字符串 &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; - Parameters: &#x2F;&#x2F;&#x2F; - start: 开始 &#x2F;&#x2F;&#x2F; - lenght: 长度 &#x2F;&#x2F;&#x2F; - Returns: 处理结果 func fy_startIndexToLenght(_ start: Int, lenght: Int) -&gt; String &#123; if start &gt; self.count &#123; return self &#125; let startIndex &#x3D; self.index(self.startIndex, offsetBy: start) if self.count &lt; (start + lenght) &#123; return String(self.suffix(from: startIndex)) &#125; let endIndex &#x3D; self.index(self.startIndex, offsetBy: start + lenght) return String(self[startIndex..&lt;endIndex]) &#125; &#x2F;&#x2F;MARK: 判断链接中是否存在中文 func fy_isIncludeChineseIn() -&gt; Bool &#123; for(_, value) in self.enumerated() &#123; if value &gt;&#x3D; &quot;\\u&#123;4E00&#125;&quot; &amp;&amp; value &lt;&#x3D; &quot;\\u&#123;9FA5&#125;&quot; &#123; return true &#125; &#125; return false &#125; &#x2F;&#x2F;MARK: 判断是否有效邮箱 &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; - Returns: 结果 func fy_isPeriodEmail() -&gt; Bool &#123; let email &#x3D; &quot;[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]&#123;2,4&#125;&quot; let regextestEmails &#x3D; NSPredicate(format: &quot;SELF MATCHES %@&quot;, email) return regextestEmails.evaluate(with: self) &#125; &#x2F;&#x2F;MARK: 判断是否有效身份证号 &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; - Returns: Bool func fy_isPeriodIdCard() -&gt; Bool &#123; if self.count !&#x3D; 18 &#123; return false &#125; let regex2 &#x3D; &quot;^(^[1-9]\\\\d&#123;7&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d&#123;3&#125;$)|(^[1-9]\\\\d&#123;5&#125;[1-9]\\\\d&#123;3&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])((\\\\d&#123;4&#125;)|\\\\d&#123;3&#125;[Xx])$)$&quot; let identityCardPredicate &#x3D; NSPredicate(format: &quot;SELF MATCHES %@&quot;, regex2) let flag &#x3D; identityCardPredicate.evaluate(with: self) if !flag &#123; &#x2F;&#x2F; 格式错误 return flag &#125; else &#123; &#x2F;&#x2F; 格式正确，判断合法性 &#x2F;&#x2F; 将前十七位加权因子保存在数组里 let idCardWiArray &#x3D; [&quot;7&quot;, &quot;9&quot;, &quot;10&quot;, &quot;5&quot;, &quot;8&quot;, &quot;4&quot;, &quot;2&quot;, &quot;1&quot;, &quot;6&quot;, &quot;3&quot;, &quot;7&quot;, &quot;9&quot;, &quot;10&quot;, &quot;5&quot;, &quot;8&quot;, &quot;4&quot;, &quot;2&quot;] &#x2F;&#x2F; 这是除以11后，可能产生的11位余数， 验证码，也保存在数组里 let idCardYArray &#x3D; [&quot;1&quot;, &quot;0&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;] var idCardArr &#x3D; [Int]() var idCardWiSum &#x3D; 0 for index in 0..&lt;17 &#123; let subStrIndex &#x3D; fy_startIndexToLenght(index, lenght: 1) let idCardWiIndex &#x3D; idCardWiArray[index] &#x2F;&#x2F; 数组保存所有乘积 idCardArr.append(Int(subStrIndex)! * Int(idCardWiIndex)!) &#125; &#x2F;&#x2F; 将所有乘积相加 for index in 0..&lt;idCardArr.count &#123; idCardWiSum +&#x3D; idCardArr[index] &#125; &#x2F;&#x2F; 计算出校验码所在数组的位置 let idCardMod &#x3D; idCardWiSum % 11 &#x2F;&#x2F; 得到最后一位身份证号码 let idCardLast &#x3D; fy_startIndexToLenght(17, lenght: 1) if idCardMod &#x3D;&#x3D; 2 &#123; if idCardLast &#x3D;&#x3D; &quot;X&quot; || idCardLast &#x3D;&#x3D; &quot;x&quot; &#123; return true &#125; else &#123; return false &#125; &#125; else &#123; if idCardLast &#x3D;&#x3D; idCardYArray[idCardMod] &#123; return true &#125; else &#123; return false &#125; &#125; &#125; &#125; &#x2F;&#x2F;MARK: 正则匹配6-12位数字和大小写字母组合 &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; - Returns: Bool func fy_checkPassword() -&gt; Bool &#123; let password &#x3D; &quot;^(?![0-9]+$)(?![a-zA-Z]+$)[a-zA-Z0-9]&#123;6,12&#125;&quot; let regextestPassword &#x3D; NSPredicate(format: &quot;SELF MATCHES %@&quot;, password) return regextestPassword.evaluate(with:self) &#125; &#x2F;&#x2F;MARK: 判断字符串是否包含其他字符串(必须全部一样) func fy_contains(find: String) -&gt; Bool&#123; return self.range(of: find) !&#x3D; nil &#125; &#x2F;&#x2F;MARK: 字符串转换成整型 func fy_toInt() -&gt; Int? &#123; return Int(self) &#125; &#x2F;&#x2F;MARK: 识别有效手机号 func fy_verifyPhoneNumber() -&gt; Bool &#123; let mobile &#x3D; &quot;^1((3[0-9]|4[5-68-9]|5[0-35-9]|6[6]|7[0-9]|8[0-9]|9[89])\\\\d&#123;8&#125;$)&quot; let regextestmobile &#x3D; NSPredicate(format: &quot;SELF MATCHES %@&quot;,mobile) return regextestmobile.evaluate(with: self) &#125; &#x2F;&#x2F;MARK: 识别是否有效座机号 eg: 021-8688995 func fy_landlineNumber() -&gt; Bool &#123; let strNum &#x3D; &quot;^(0\\\\d&#123;2,3&#125;-?\\\\d&#123;7,8&#125;$)&quot; let checktest &#x3D; NSPredicate.init(format: &quot;SELF MATCHES %@&quot;, strNum) let isPhone &#x3D; checktest.evaluate(with: self) let strNum1 &#x3D; &quot;^(\\\\d&#123;7,8&#125;$)&quot; let checktest1 &#x3D; NSPredicate.init(format: &quot;SELF MATCHES %@&quot;, strNum1) let isPhone1 &#x3D; checktest1.evaluate(with: self) if isPhone || isPhone1 &#123; return true &#125; else &#123; return false &#125; &#125; &#125;extension Array&#123; &#x2F;&#x2F;MARK: 数组转JSON字符串 func arrayToString() -&gt; String? &#123; if let data &#x3D; try? JSONSerialization.data(withJSONObject: self, options: JSONSerialization.WritingOptions.init(rawValue: 0)) &#123; if let jsonStr &#x3D; String.init(data: data, encoding: String.Encoding.utf8) &#123; return jsonStr &#125; &#125; return nil &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"Swift Method","slug":"Swift-Method","permalink":"https://ifeiyv.github.io/tags/Swift-Method/"}]},{"title":"SWIFT关键字","slug":"SWIFT关键字","date":"2019-06-06T05:39:18.000Z","updated":"2020-03-17T07:32:39.225Z","comments":true,"path":"2019/06/06/SWIFT关键字/","link":"","permalink":"https://ifeiyv.github.io/2019/06/06/SWIFT%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"@discardableResult 修饰的方法有返回值，调用时可以不接收返回值，并且不会出现警告⚠️ IBInspectable 属性声明的时候加上 IBInspectable 修饰，Xcode 会自动添加到 Storyboard 中 Attributes inspector 栏目中 typealias 定义了一个类型别名","categories":[{"name":"Swift","slug":"Swift","permalink":"https://ifeiyv.github.io/categories/Swift/"}],"tags":[{"name":"Swift关键字","slug":"Swift关键字","permalink":"https://ifeiyv.github.io/tags/Swift%E5%85%B3%E9%94%AE%E5%AD%97/"}]}]}